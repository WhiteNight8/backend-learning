# GORM 完整指南

##  GORM 基础使用方法

GORM 是 Go 语言中最流行的 ORM (对象关系映射) 框架，它提供了简洁、优雅的 API 来操作数据库。

### 安装

```go
go get -u gorm.io/gorm
go get -u gorm.io/driver/mysql // 或其他数据库驱动
```

## 

### 连接数据库

```go
package main

import (
  "gorm.io/driver/mysql"
  "gorm.io/gorm"
)

func main() {
  dsn := "user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local"
  db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
  if err != nil {
    panic("failed to connect database")
  }
  
  // 获取通用数据库对象 sql.DB，用于设置连接池等
  sqlDB, err := db.DB()
  
  // 设置连接池参数
  sqlDB.SetMaxIdleConns(10)
  sqlDB.SetMaxOpenConns(100)
}
```



### 基础 CRUD 操作

定义一个模型：

```go
type User struct {
  ID        uint   `gorm:"primaryKey"`
  Name      string
  Age       int
  Email     string `gorm:"uniqueIndex"`
  CreatedAt time.Time
  UpdatedAt time.Time
}
```



基础操作：

```go
// 创建记录
user := User{Name: "张三", Age: 18, Email: "zhangsan@example.com"}
result := db.Create(&user)
if result.Error != nil {
  // 处理错误
}
fmt.Println(user.ID) // 创建后会自动填充 ID

// 读取记录
var user User
db.First(&user, 1) // 查找 ID 为 1 的记录
db.First(&user, "name = ?", "张三") // 查找 name 为张三的第一条记录

// 更新记录
db.Model(&user).Update("Name", "李四") // 更新单个字段
db.Model(&user).Updates(User{Name: "李四", Age: 20}) // 更新多个字段
db.Model(&user).Updates(map[string]interface{}{"name": "李四", "age": 20})

// 删除记录
db.Delete(&user, 1) // 删除 ID 为 1 的记录
```



## 模型定义与表关系映射

### 基本模型定义

```go
type Product struct {
  gorm.Model           // 内嵌 gorm.Model (包含 ID, CreatedAt, UpdatedAt, DeletedAt)
  Code        string   `gorm:"type:varchar(100);unique_index"`
  Price       uint     `gorm:"default:0"`
  Description string   `gorm:"size:255"`
  UserID      uint     // 外键
  User        User     `gorm:"foreignKey:UserID"` // 关联关系
}
```



### 表名与字段名

默认情况下，GORM 会将结构体名转换为蛇形命名作为表名（例如 `UserProfile` → `user_profiles`），字段名也会转换为蛇形命名。可以通过以下方法自定义：

```go
// 自定义表名
func (User) TableName() string {
  return "custom_user_table"
}

// 全局表名设置
db.NamingStrategy = schema.NamingStrategy{
  TablePrefix: "t_",   // 表前缀
  SingularTable: true, // 使用单数表名
}
```



### 关系映射

GORM 支持以下几种主要关系类型：

**一对一关系**

```go
// 用户和用户资料是一对一关系
type User struct {
  ID         uint
  Name       string
  ProfileID  uint
  Profile    Profile
}

type Profile struct {
  ID     uint
  Bio    string
  UserID uint `gorm:"uniqueIndex"` // 一对一关系中的外键
}
```

**一对多关系**

```go
// 用户和订单是一对多关系
type User struct {
  ID      uint
  Name    string
  Orders  []Order
}

type Order struct {
  ID     uint
  Amount float64
  UserID uint
}
```

**多对多关系**

```go
// 用户和角色是多对多关系
type User struct {
  ID     uint
  Name   string
  Roles  []Role `gorm:"many2many:user_roles;"` // 使用连接表
}

type Role struct {
  ID   uint
  Name string
  Users []User `gorm:"many2many:user_roles;"`
}
```

多态关系

```go
type Comment struct {
  ID        uint
  Content   string
  CommentableID   uint
  CommentableType string
}

type Article struct {
  ID       uint
  Title    string
  Comments []Comment `gorm:"polymorphic:Commentable;"`
}

type Video struct {
  ID       uint
  Name     string
  Comments []Comment `gorm:"polymorphic:Commentable;"`
}
```



## 基本查询操作与条件构建

### 基本查询方法

```go
// 获取第一条记录
var user User
db.First(&user)

// 获取最后一条记录
db.Last(&user)

// 获取所有记录
var users []User
db.Find(&users)

// 获取指定的记录
db.Find(&users, []int{1, 2, 3})
```



### 条件查询

```go
// 简单条件
db.Where("name = ?", "张三").First(&user)

// 多条件
db.Where("name = ? AND age >= ?", "张三", 18).Find(&users)

// 结构体条件
db.Where(&User{Name: "张三", Age: 18}).First(&user)

// Map 条件
db.Where(map[string]interface{}{"name": "张三", "age": 18}).Find(&users)

// IN 条件
db.Where("name IN ?", []string{"张三", "李四"}).Find(&users)

// LIKE 条件
db.Where("name LIKE ?", "%张%").Find(&users)

// AND 条件链式调用
db.Where("name = ?", "张三").Where("age > ?", 18).Find(&users)

// OR 条件
db.Where("name = ?", "张三").Or("name = ?", "李四").Find(&users)
```



### 高级查询

```go
// 排序
db.Order("age desc, name").Find(&users)

// 分页
db.Limit(10).Offset(0).Find(&users) // 第一页，每页10条
db.Limit(10).Offset(10).Find(&users) // 第二页，每页10条

// 分组与聚合
type Result struct {
  Age   int
  Count int
}
var results []Result
db.Model(&User{}).Select("age, count(*) as count").Group("age").Having("count > ?", 1).Find(&results)

// 子查询
db.Where("age > (?)", db.Table("users").Select("AVG(age)")).Find(&users)

// 原生 SQL
db.Raw("SELECT name, age FROM users WHERE age > ?", 18).Scan(&users)
```



### Scopes（查询作用域）

```go
func AgeGreaterThan(age int) func(db *gorm.DB) *gorm.DB {
  return func(db *gorm.DB) *gorm.DB {
    return db.Where("age > ?", age)
  }
}

func NameLike(name string) func(db *gorm.DB) *gorm.DB {
  return func(db *gorm.DB) *gorm.DB {
    return db.Where("name LIKE ?", "%"+name+"%")
  }
}

// 使用 Scopes
db.Scopes(AgeGreaterThan(18), NameLike("张")).Find(&users)
```



## 事务管理与钩子方法

### 事务管理

```go
// 自动事务
err := db.Transaction(func(tx *gorm.DB) error {
  // 在事务中进行操作
  if err := tx.Create(&user).Error; err != nil {
    return err // 返回任何错误都会回滚事务
  }
  
  if err := tx.Create(&order).Error; err != nil {
    return err
  }
  
  // 返回 nil 提交事务
  return nil
})

// 手动事务
tx := db.Begin()

// 出错时回滚
defer func() {
  if r := recover(); r != nil {
    tx.Rollback()
  }
}()

if err := tx.Create(&user).Error; err != nil {
  tx.Rollback()
  return err
}

if err := tx.Create(&order).Error; err != nil {
  tx.Rollback()
  return err
}

// 提交事务
return tx.Commit().Error
```



### 钩子方法

GORM 提供了一系列的钩子方法，允许您在特定的生命周期事件中注入自定义逻辑：

```go
type User struct {
  ID        uint
  Name      string
  Age       int
  Email     string
  Password  string `gorm:"-"` // 不存储到数据库
  EncryptedPassword string
}

// 创建前的钩子，用于密码加密
func (u *User) BeforeCreate(tx *gorm.DB) (err error) {
  u.EncryptedPassword = hashPassword(u.Password)
  return
}

// 其他可用的钩子方法:
// BeforeSave
// AfterSave
// BeforeCreate
// AfterCreate
// BeforeUpdate
// AfterUpdate
// BeforeDelete
// AfterDelete
// AfterFind
```



## 关联查询与预加载

### 关联查询

在 GORM 中，关联查询可以通过模型关系直接访问：

```go
// 查找用户并加载其所有订单
var user User
db.First(&user, 1)
var orders []Order
db.Model(&user).Association("Orders").Find(&orders)

// 添加关联
db.Model(&user).Association("Orders").Append(&Order{Amount: 100})

// 替换关联
db.Model(&user).Association("Orders").Replace(&newOrders)

// 删除关联
db.Model(&user).Association("Orders").Delete(&orderToDelete)

// 清空关联
db.Model(&user).Association("Orders").Clear()

// 获取关联计数
count := db.Model(&user).Association("Orders").Count()
```



### 预加载（Preload）

预加载允许您在单个查询中加载关联数据，避免 N+1 查询问题：

```go
// 预加载单个关联
var users []User
db.Preload("Orders").Find(&users)

// 预加载多个关联
db.Preload("Orders").Preload("Profile").Find(&users)

// 嵌套预加载
db.Preload("Orders.Items").Find(&users)

// 条件预加载
db.Preload("Orders", "state = ?", "paid").Find(&users)

// 自定义预加载
db.Preload("Orders", func(db *gorm.DB) *gorm.DB {
  return db.Order("orders.created_at DESC").Limit(5)
}).Find(&users)
```

### 即时加载（Joins）

使用 Joins 进行即时加载：

```go
type Result struct {
  Name  string
  Email string
}

var results []Result

// 使用关联名称连接
db.Model(&User{}).Select("users.name, emails.email").Joins("left join emails on emails.user_id = users.id").Scan(&results)

// 预加载与连接结合
db.Joins("Profile").Find(&users)
```



## 迁移与数据库版本管理

### 自动迁移

GORM 提供了 AutoMigrate 功能，它会自动根据模型定义更新数据库表结构：

```go
// 迁移单个模型
db.AutoMigrate(&User{})

// 迁移多个模型
db.AutoMigrate(&User{}, &Product{}, &Order{})
```

注意：AutoMigrate 会创建表、缺失的外键、约束、列和索引。为了保护数据，它不会更改现有列的类型或删除未使用的列。



### 手动迁移

对于更精细的控制，可以使用 GORM 的 Migrator 接口：

```go
// 检查表是否存在
exist := db.Migrator().HasTable(&User{})

// 创建表
db.Migrator().CreateTable(&User{})

// 删除表
db.Migrator().DropTable(&User{})

// 添加外键
db.Migrator().CreateConstraint(&User{}, "Orders")

// 删除外键
db.Migrator().DropConstraint(&User{}, "Orders")

// 添加索引
db.Migrator().CreateIndex(&User{}, "idx_name")

// 删除索引
db.Migrator().DropIndex(&User{}, "idx_name")
```



### 数据库版本管理

对于生产环境，建议使用专门的数据库迁移工具，如 go-migrate 或 goose：

```go
// 使用 go-migrate 示例
package main

import (
  "log"
  "database/sql"
  "github.com/golang-migrate/migrate/v4"
  "github.com/golang-migrate/migrate/v4/database/mysql"
  _ "github.com/golang-migrate/migrate/v4/source/file"
)

func main() {
  db, err := sql.Open("mysql", "dsn")
  if err != nil {
    log.Fatal(err)
  }
  
  driver, err := mysql.WithInstance(db, &mysql.Config{})
  if err != nil {
    log.Fatal(err)
  }
  
  m, err := migrate.NewWithDatabaseInstance(
    "file://migrations",
    "mysql", 
    driver,
  )
  if err != nil {
    log.Fatal(err)
  }
  
  if err := m.Up(); err != nil && err != migrate.ErrNoChange {
    log.Fatal(err)
  }
}
```



## ORM 性能优化与 N+1 问题处理

### N+1 问题

N+1 查询问题是指在获取关联数据时，除了执行一个主查询外，还为每个主记录执行一个附加查询：

```go
// 错误示例：导致 N+1 问题
var users []User
db.Find(&users) // 1 个查询获取所有用户

for _, user := range users {
  var orders []Order
  db.Model(&user).Association("Orders").Find(&orders) // 每个用户执行 1 个查询获取订单
  // 这将导致 N+1 查询问题
}
```



### 解决 N+1 问题

主要通过预加载（Preload）或连接（Joins）来解决：

```go
// 使用 Preload 解决 N+1 问题
var users []User
db.Preload("Orders").Find(&users) // 只执行 2 个查询：1 个查询用户，1 个查询所有相关订单

// 使用 Joins 解决 N+1 问题
var users []User
db.Joins("LEFT JOIN orders ON orders.user_id = users.id").Find(&users)
```



### 查询优化

1. **使用索引**

```go
// 添加索引
type User struct {
  ID    uint   `gorm:"primaryKey"`
  Name  string `gorm:"index"`
  Email string `gorm:"uniqueIndex"`
  // 复合索引
  `gorm:"index:idx_name_email,unique"`
}
```

1. **选择特定字段**

```go
// 只选择需要的字段
db.Select("name", "age").Find(&users)
```

1. **批量操作**

```go
// 使用批量创建
var users = []User{{Name: "张三"}, {Name: "李四"}, {Name: "王五"}}
db.CreateInBatches(users, 100) // 每批 100 条
```

1. **查询缓存**

使用 Redis 或其他缓存系统缓存常用查询结果：

```go
func GetUserByID(id uint) (User, error) {
  cacheKey := fmt.Sprintf("user:%d", id)
  
  // 尝试从缓存获取
  if cachedUser, found := cache.Get(cacheKey); found {
    return cachedUser.(User), nil
  }
  
  // 从数据库获取
  var user User
  if err := db.First(&user, id).Error; err != nil {
    return User{}, err
  }
  
  // 存入缓存
  cache.Set(cacheKey, user, time.Minute*10)
  
  return user, nil
}
```

1. **避免使用 Find(&allRecords) 加载所有记录**

```go
// 不要这样做
var users []User
db.Find(&users) // 加载所有记录

// 应该这样做
var users []User
db.Limit(100).Find(&users) // 限制记录数量
```

1. **使用 Database/SQL 原生查询**

对于极端性能要求的场景，考虑使用原生 SQL：

```go
var users []struct {
  Name string
  Age  int
}

db.Raw("SELECT name, age FROM users WHERE age > ? LIMIT 10", 18).Scan(&users)
```

1. **连接池优化**

```go
sqlDB, err := db.DB()
// 设置最大空闲连接数
sqlDB.SetMaxIdleConns(10)
// 设置最大打开连接数
sqlDB.SetMaxOpenConns(100)
// 设置连接最大生存时间
sqlDB.SetConnMaxLifetime(time.Hour)
```

1. **使用事务处理批量操作**

```go
err := db.Transaction(func(tx *gorm.DB) error {
  // 在事务中批量处理
  for i := 0; i < 1000; i++ {
    if err := tx.Create(&User{Name: fmt.Sprintf("用户%d", i)}).Error; err != nil {
      return err
    }
  }
  return nil
})
```

### 监控与分析

GORM 提供了日志和性能分析功能：

```go
// 启用详细日志记录
db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
  Logger: logger.Default.LogMode(logger.Info),
})

// 自定义日志器
newLogger := logger.New(
  log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer
  logger.Config{
    SlowThreshold: time.Second,              // 慢查询阈值
    LogLevel:      logger.Info,              // 日志级别
    Colorful:      true,                     // 彩色输出
  },
)

db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
  Logger: newLogger,
})
```
