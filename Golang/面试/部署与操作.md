# éƒ¨ç½²ä¸æ“ä½œ

## Go build å‘½ä»¤ä¸å¸¸ç”¨å‚æ•°

### åŸºæœ¬ç”¨æ³•

```bash
# ç¼–è¯‘å½“å‰ç›®å½•ä¸‹çš„åŒ…
go build

# ç¼–è¯‘æŒ‡å®šåŒ…
go build ./cmd/myapp
go build github.com/user/project/cmd/server

# æŒ‡å®šè¾“å‡ºæ–‡ä»¶å
go build -o myapp
go build -o bin/server ./cmd/server
```

### å¸¸ç”¨å‚æ•°è¯¦è§£

#### åŸºç¡€å‚æ•°

- `-o filename`: æŒ‡å®šè¾“å‡ºæ–‡ä»¶å
- `-v`: æ˜¾ç¤ºæ­£åœ¨ç¼–è¯‘çš„åŒ…å
- `-a`: å¼ºåˆ¶é‡æ–°ç¼–è¯‘æ‰€æœ‰åŒ…
- `-n`: æ˜¾ç¤ºç¼–è¯‘å‘½ä»¤ä½†ä¸æ‰§è¡Œ
- `-x`: æ˜¾ç¤ºè¯¦ç»†çš„ç¼–è¯‘è¿‡ç¨‹

#### ç¼–è¯‘ä¼˜åŒ–å‚æ•°

- `-ldflags`: ä¼ é€’ç»™é“¾æ¥å™¨çš„å‚æ•°
- `-gcflags`: ä¼ é€’ç»™ç¼–è¯‘å™¨çš„å‚æ•°
- `-tags`: æŒ‡å®šæ„å»ºæ ‡ç­¾
- `-race`: å¯ç”¨ç«æ€æ£€æµ‹
- `-msan`: å¯ç”¨å†…å­˜å®‰å…¨æ£€æµ‹

#### å®ç”¨ç¤ºä¾‹

```bash
# ä¼˜åŒ–ç¼–è¯‘ï¼Œå»é™¤è°ƒè¯•ä¿¡æ¯
go build -ldflags "-s -w" -o myapp

# åµŒå…¥ç‰ˆæœ¬ä¿¡æ¯
go build -ldflags "-X main.version=1.0.0 -X main.buildTime=$(date)" -o myapp

# å¯ç”¨ç«æ€æ£€æµ‹
go build -race -o myapp

# æ˜¾ç¤ºè¯¦ç»†ç¼–è¯‘è¿‡ç¨‹
go build -v -x -o myapp
```



## äº¤å‰ç¼–è¯‘ä¸å¤šå¹³å°æ”¯æŒ



### ç¯å¢ƒå˜é‡è®¾ç½®

```bash
# æŸ¥çœ‹æ”¯æŒçš„å¹³å°
go tool dist list

# è®¾ç½®ç›®æ ‡æ“ä½œç³»ç»Ÿå’Œæ¶æ„
export GOOS=linux
export GOARCH=amd64

# æˆ–è€…ç›´æ¥åœ¨å‘½ä»¤ä¸­è®¾ç½®
GOOS=windows GOARCH=amd64 go build -o myapp.exe
```

### å¸¸è§å¹³å°ç»„åˆ

```bash
# Linux 64ä½
GOOS=linux GOARCH=amd64 go build -o myapp-linux-amd64

# Windows 64ä½
GOOS=windows GOARCH=amd64 go build -o myapp-windows-amd64.exe

# macOS 64ä½ (Intel)
GOOS=darwin GOARCH=amd64 go build -o myapp-darwin-amd64

# macOS ARM64 (Apple Silicon)
GOOS=darwin GOARCH=arm64 go build -o myapp-darwin-arm64

# ARM Linux
GOOS=linux GOARCH=arm64 go build -o myapp-linux-arm64
```

### æ‰¹é‡äº¤å‰ç¼–è¯‘è„šæœ¬

```bash
#!/bin/bash
APP_NAME="myapp"
VERSION="1.0.0"

platforms=(
    "linux/amd64"
    "linux/arm64"
    "darwin/amd64"
    "darwin/arm64"
    "windows/amd64"
)

for platform in "${platforms[@]}"
do
    platform_split=(${platform//\// })
    GOOS=${platform_split[0]}
    GOARCH=${platform_split[1]}
    
    output_name=$APP_NAME'-'$VERSION'-'$GOOS'-'$GOARCH
    if [ $GOOS = "windows" ]; then
        output_name+='.exe'
    fi
    
    env GOOS=$GOOS GOARCH=$GOARCH go build -o $output_name
    if [ $? -ne 0 ]; then
        echo 'An error has occurred! Aborting the script execution...'
        exit 1
    fi
done
```

### CGO ç›¸å…³æ³¨æ„äº‹é¡¹

```bash
# ç¦ç”¨CGOè¿›è¡Œçº¯Goäº¤å‰ç¼–è¯‘
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build

# å¯ç”¨CGOéœ€è¦å¯¹åº”å¹³å°çš„Cç¼–è¯‘å™¨
CGO_ENABLED=1 CC=x86_64-linux-gnu-gcc GOOS=linux GOARCH=amd64 go build
```



## æ„å»ºæ ‡ç­¾ä¸æ¡ä»¶ç¼–è¯‘

### æ„å»ºæ ‡ç­¾è¯­æ³•

```go
//go:build linux
// +build linux

package main

import "fmt"

func main() {
    fmt.Println("This runs only on Linux")
}
```



### å¤æ‚æ„å»ºæ ‡ç­¾

```go
// ä»…åœ¨Linuxæˆ–Windowsä¸Šç¼–è¯‘
//go:build linux || windows

// åœ¨Linuxä¸Šä½†æ’é™¤ARMæ¶æ„
//go:build linux && !arm

// å¤šæ¡ä»¶ç»„åˆ
//go:build (linux && amd64) || (darwin && !cgo)
```





### æŒ‰åŠŸèƒ½åˆ†ç»„çš„æ„å»ºæ ‡ç­¾

```go
// database_postgres.go
//go:build postgres
package db

func Connect() {
    // PostgreSQL connection
}

// database_mysql.go  
//go:build mysql
package db

func Connect() {
    // MySQL connection
}

// ä½¿ç”¨ç‰¹å®šæ•°æ®åº“ç¼–è¯‘
go build -tags postgres
go build -tags mysql
```



### å¼€å‘å’Œç”Ÿäº§ç¯å¢ƒåŒºåˆ†

```go
// config_dev.go
//go:build dev
package config

var (
    DBHost = "localhost"
    Debug  = true
)

// config_prod.go
//go:build prod
package config

var (
    DBHost = "prod.db.example.com"
    Debug  = false
)
```





## ç¼–è¯‘æ—¶ä¼˜åŒ–ä¸é“¾æ¥é€‰é¡¹

### é“¾æ¥å™¨é€‰é¡¹ (-ldflags)

```bash
# åŸºæœ¬ä¼˜åŒ–
go build -ldflags "-s -w"
# -s: å»é™¤ç¬¦å·è¡¨
# -w: å»é™¤DWARFè°ƒè¯•ä¿¡æ¯

# è®¾ç½®å˜é‡å€¼
go build -ldflags "-X main.version=1.0.0 -X main.buildTime=$(date)"

# å‡å°äºŒè¿›åˆ¶å¤§å°
go build -ldflags "-s -w -extldflags '-static'"

# å®Œæ•´ä¼˜åŒ–ç¤ºä¾‹
go build -ldflags "-s -w -X main.version=1.0.0 -X main.buildDate=$(date -u +%Y-%m-%d) -X main.gitCommit=$(git rev-parse HEAD)"
```



### ç¼–è¯‘å™¨é€‰é¡¹ (-gcflags)

```bash
# ç¦ç”¨ä¼˜åŒ–ï¼ˆè°ƒè¯•ç”¨ï¼‰
go build -gcflags "-N -l"

# å¯ç”¨æ‰€æœ‰ä¼˜åŒ–
go build -gcflags "-O=2"

# å†…è”ç»Ÿè®¡
go build -gcflags "-m"

# é€ƒé€¸åˆ†æ
go build -gcflags "-m -m"
```



### ç‰ˆæœ¬ä¿¡æ¯åµŒå…¥ç¤ºä¾‹

```go
// main.go
package main

import (
    "fmt"
    "runtime"
)

var (
    version   = "dev"
    buildDate = "unknown"
    gitCommit = "unknown"
)

func main() {
    fmt.Printf("Version: %s\n", version)
    fmt.Printf("Build Date: %s\n", buildDate)
    fmt.Printf("Git Commit: %s\n", gitCommit)
    fmt.Printf("Go Version: %s\n", runtime.Version())
}
```



### Makefile æ„å»ºç¤ºä¾‹

```makefile
APP_NAME := myapp
VERSION := $(shell git describe --tags --always --dirty)
BUILD_DATE := $(shell date -u +%Y-%m-%d)
GIT_COMMIT := $(shell git rev-parse HEAD)

LDFLAGS := -s -w \
    -X main.version=$(VERSION) \
    -X main.buildDate=$(BUILD_DATE) \
    -X main.gitCommit=$(GIT_COMMIT)

.PHONY: build
build:
	go build -ldflags "$(LDFLAGS)" -o $(APP_NAME)

.PHONY: build-all
build-all:
	GOOS=linux GOARCH=amd64 go build -ldflags "$(LDFLAGS)" -o $(APP_NAME)-linux-amd64
	GOOS=darwin GOARCH=amd64 go build -ldflags "$(LDFLAGS)" -o $(APP_NAME)-darwin-amd64
	GOOS=windows GOARCH=amd64 go build -ldflags "$(LDFLAGS)" -o $(APP_NAME)-windows-amd64.exe
```





## æ„å»ºçº¦æŸä¸æ–‡ä»¶åç¼€

### æ–‡ä»¶ååç¼€çº¦å®š

```
main.go          // æ‰€æœ‰å¹³å°
main_linux.go    // ä»…Linux
main_windows.go  // ä»…Windows
main_darwin.go   // ä»…macOS
main_unix.go     // Unix-likeç³»ç»Ÿ
main_amd64.go    // AMD64æ¶æ„
main_arm64.go    // ARM64æ¶æ„
```

### ç»„åˆåç¼€

```
config_linux_amd64.go     // Linux + AMD64
config_darwin_arm64.go    // macOS + ARM64
config_windows_386.go     // Windows + 386
```

### ç›®å½•ç»“æ„ç¤ºä¾‹

```
project/
â”œâ”€â”€ main.go
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ config.go
â”‚   â”œâ”€â”€ config_dev.go
â”‚   â”œâ”€â”€ config_prod.go
â”‚   â”œâ”€â”€ config_linux.go
â”‚   â”œâ”€â”€ config_windows.go
â”‚   â””â”€â”€ config_darwin.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ service_unix.go
â”‚   â”œâ”€â”€ service_windows.go
â”‚   â”œâ”€â”€ storage_postgres.go
â”‚   â””â”€â”€ storage_mysql.go
â””â”€â”€ build/
    â”œâ”€â”€ Dockerfile
    â””â”€â”€ build.sh
```

### æ„å»ºçº¦æŸæœ€ä½³å®è·µ

```go
// ä½¿ç”¨æ–°çš„go:buildè¯­æ³•
//go:build !windows
package unix

// ç»“åˆå¤šä¸ªæ¡ä»¶
//go:build (linux || darwin) && amd64 && !appengine

// æµ‹è¯•æ–‡ä»¶çº¦æŸ
//go:build integration
package main_test
```



## å°† Go åº”ç”¨æ‰“åŒ…ä¸º Docker é•œåƒ

### åŸºç¡€ Dockerfile

```dockerfile
# åŸºç¡€é•œåƒ
FROM golang:1.21-alpine AS builder

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY go.mod go.sum ./

# ä¸‹è½½ä¾èµ–
RUN go mod download

# å¤åˆ¶æºä»£ç 
COPY . .

# ç¼–è¯‘åº”ç”¨
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags "-s -w" -o main .

# è¿è¡Œé•œåƒ
FROM alpine:latest

# å®‰è£…ca-certificatesç”¨äºHTTPSè¯·æ±‚
RUN apk --no-cache add ca-certificates

# åˆ›å»ºérootç”¨æˆ·
RUN addgroup -g 1001 appgroup && \
    adduser -u 1001 -G appgroup -s /bin/sh -D appuser

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /root/

# ä»æ„å»ºé˜¶æ®µå¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /app/main .

# åˆ‡æ¢åˆ°érootç”¨æˆ·
USER appuser

# æš´éœ²ç«¯å£
EXPOSE 8080

# è¿è¡Œåº”ç”¨
CMD ["./main"]
```



### å¤šé˜¶æ®µæ„å»ºä¼˜åŒ–

```dockerfile
# ç¬¬ä¸€é˜¶æ®µï¼šæ„å»º
FROM golang:1.21-alpine AS builder

# å®‰è£…æ„å»ºä¾èµ–
RUN apk add --no-cache git

# è®¾ç½®Goç¯å¢ƒ
ENV GO111MODULE=on \
    CGO_ENABLED=0 \
    GOOS=linux \
    GOARCH=amd64

WORKDIR /build

# ä¼˜åŒ–å±‚ç¼“å­˜
COPY go.mod go.sum ./
RUN go mod download

# å¤åˆ¶æºç å¹¶æ„å»º
COPY . .
RUN go build -ldflags "-s -w -extldflags '-static'" -o app .

# ç¬¬äºŒé˜¶æ®µï¼šè¿è¡Œ
FROM scratch

# ä»æ„å»ºé˜¶æ®µå¤åˆ¶
COPY --from=builder /build/app /
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# è¿è¡Œåº”ç”¨
ENTRYPOINT ["/app"]
```



### ä½¿ç”¨ distroless é•œåƒ

```dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 go build -ldflags "-s -w" -o main .

# ä½¿ç”¨Googleçš„distrolessé•œåƒ
FROM gcr.io/distroless/static-debian11

COPY --from=builder /app/main /

USER 1000:1000

ENTRYPOINT ["/main"]
```



### Docker Compose ç¤ºä¾‹

```yaml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=db
      - DB_USER=postgres
      - DB_PASSWORD=password
    depends_on:
      - db
    restart: unless-stopped

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  postgres_data:
```



### æ„å»ºè„šæœ¬

```bash
#!/bin/bash
set -e

APP_NAME="myapp"
VERSION=${1:-latest}
REGISTRY="your-registry.com"

echo "Building Docker image..."
docker build -t $APP_NAME:$VERSION .
docker tag $APP_NAME:$VERSION $REGISTRY/$APP_NAME:$VERSION

echo "Running security scan..."
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  -v $HOME/Library/Caches:/root/.cache/ \
  aquasec/trivy image $APP_NAME:$VERSION

if [ "$2" = "push" ]; then
    echo "Pushing to registry..."
    docker push $REGISTRY/$APP_NAME:$VERSION
fi

echo "Build completed: $REGISTRY/$APP_NAME:$VERSION"
```



## Go åº”ç”¨çš„ç‰ˆæœ¬ç®¡ç†ä¸å‘å¸ƒ

### è¯­ä¹‰åŒ–ç‰ˆæœ¬æ§åˆ¶

```bash
# æ ‡è®°ç‰ˆæœ¬
git tag -a v1.0.0 -m "Release version 1.0.0"
git push origin v1.0.0

# æŸ¥çœ‹ç‰ˆæœ¬
git describe --tags --always --dirty
```



### ç‰ˆæœ¬ä¿¡æ¯é›†æˆ

```go
// version.go
package main

import (
    "fmt"
    "runtime"
)

var (
    // è¿™äº›å˜é‡åœ¨ç¼–è¯‘æ—¶é€šè¿‡-ldflagsè®¾ç½®
    Version   = "dev"
    BuildDate = "unknown"
    GitCommit = "unknown"
    GitBranch = "unknown"
)

type BuildInfo struct {
    Version    string `json:"version"`
    BuildDate  string `json:"build_date"`
    GitCommit  string `json:"git_commit"`
    GitBranch  string `json:"git_branch"`
    GoVersion  string `json:"go_version"`
    Platform   string `json:"platform"`
}

func GetBuildInfo() BuildInfo {
    return BuildInfo{
        Version:   Version,
        BuildDate: BuildDate,
        GitCommit: GitCommit,
        GitBranch: GitBranch,
        GoVersion: runtime.Version(),
        Platform:  fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH),
    }
}

func PrintVersion() {
    info := GetBuildInfo()
    fmt.Printf("Version: %s\n", info.Version)
    fmt.Printf("Build Date: %s\n", info.BuildDate)
    fmt.Printf("Git Commit: %s\n", info.GitCommit)
    fmt.Printf("Git Branch: %s\n", info.GitBranch)
    fmt.Printf("Go Version: %s\n", info.GoVersion)
    fmt.Printf("Platform: %s\n", info.Platform)
}
```



### GitHub Actions è‡ªåŠ¨å‘å¸ƒ

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    name: Build and Release
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.21

    - name: Get version
      id: version
      run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Build binaries
      run: |
        make build-all VERSION=${{ steps.version.outputs.VERSION }}

    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        draft: false
        prerelease: false

    - name: Upload binaries
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./dist/
        asset_name: myapp-${{ steps.version.outputs.VERSION }}
        asset_content_type: application/octet-stream
```



### GoReleaser é…ç½®

```yaml
# .goreleaser.yml
project_name: myapp

before:
  hooks:
    - go mod tidy
    - go generate ./...

builds:
  - env:
      - CGO_ENABLED=0
    goos:
      - linux
      - windows
      - darwin
    goarch:
      - amd64
      - arm64
    ldflags:
      - -s -w
      - -X main.version={{.Version}}
      - -X main.buildDate={{.Date}}
      - -X main.gitCommit={{.Commit}}

archives:
  - format: tar.gz
    name_template: >-
      {{ .ProjectName }}_
      {{- title .Os }}_
      {{- if eq .Arch "amd64" }}x86_64
      {{- else if eq .Arch "386" }}i386
      {{- else }}{{ .Arch }}{{ end }}
    format_overrides:
    - goos: windows
      format: zip

checksum:
  name_template: 'checksums.txt'

snapshot:
  name_template: "{{ incpatch .Version }}-next"

changelog:
  sort: asc
  filters:
    exclude:
      - '^docs:'
      - '^test:'

dockers:
  - image_templates:
    - "your-registry/{{.ProjectName}}:{{ .Tag }}"
    - "your-registry/{{.ProjectName}}:latest"
    dockerfile: Dockerfile
```

### å‘å¸ƒæµç¨‹æœ€ä½³å®è·µ

#### 1. ç‰ˆæœ¬å·è§„èŒƒ

```bash
# ä¸»ç‰ˆæœ¬.æ¬¡ç‰ˆæœ¬.ä¿®è®¢ç‰ˆæœ¬
v1.0.0    # ç¨³å®šç‰ˆæœ¬
v1.0.1    # bugä¿®å¤
v1.1.0    # æ–°åŠŸèƒ½
v2.0.0    # ç ´åæ€§å˜æ›´

# é¢„å‘å¸ƒç‰ˆæœ¬
v1.0.0-alpha.1
v1.0.0-beta.1
v1.0.0-rc.1
```

#### 2. å‘å¸ƒæ£€æŸ¥æ¸…å•

```bash
#!/bin/bash
# release-checklist.sh

echo "ğŸ” Pre-release checklist:"

echo "âœ… Running tests..."
go test ./...

echo "âœ… Running linter..."
golangci-lint run

echo "âœ… Checking security..."
gosec ./...

echo "âœ… Updating dependencies..."
go mod tidy
go mod verify

echo "âœ… Building for all platforms..."
make build-all

echo "âœ… Running integration tests..."
make test-integration

echo "ğŸš€ Ready for release!"
```

#### 3. è‡ªåŠ¨åŒ–å‘å¸ƒè„šæœ¬

```bash
#!/bin/bash
# release.sh

VERSION=$1
if [ -z "$VERSION" ]; then
    echo "Usage: $0 <version>"
    exit 1
fi

echo "ğŸ—ï¸  Preparing release $VERSION..."

# è¿è¡Œæ£€æŸ¥
./scripts/release-checklist.sh

# åˆ›å»ºæ ‡ç­¾
git tag -a $VERSION -m "Release $VERSION"

# æ¨é€æ ‡ç­¾è§¦å‘CI/CD
git push origin $VERSION

echo "ğŸ‰ Release $VERSION initiated!"
echo "Check GitHub Actions for build status."
```





# Goé…ç½®ä¸ç¯å¢ƒç®¡ç†

## å‘½ä»¤è¡Œå‚æ•°è§£æä¸ flag åŒ…

### åŸºç¡€ flag åŒ…ä½¿ç”¨

```go
package main

import (
    "flag"
    "fmt"
    "os"
    "time"
)

func main() {
    // å®šä¹‰å‘½ä»¤è¡Œå‚æ•°
    var (
        port     = flag.Int("port", 8080, "æœåŠ¡å™¨ç«¯å£")
        host     = flag.String("host", "localhost", "æœåŠ¡å™¨ä¸»æœº")
        debug    = flag.Bool("debug", false, "æ˜¯å¦å¯ç”¨è°ƒè¯•æ¨¡å¼")
        timeout  = flag.Duration("timeout", 30*time.Second, "è¯·æ±‚è¶…æ—¶æ—¶é—´")
        config   = flag.String("config", "config.yaml", "é…ç½®æ–‡ä»¶è·¯å¾„")
        verbose  = flag.Bool("v", false, "è¯¦ç»†è¾“å‡º")
    )

    // è‡ªå®šä¹‰ç”¨æ³•ä¿¡æ¯
    flag.Usage = func() {
        fmt.Fprintf(os.Stderr, "ç”¨æ³•: %s [é€‰é¡¹]\n", os.Args[0])
        fmt.Fprintf(os.Stderr, "é€‰é¡¹:\n")
        flag.PrintDefaults()
    }

    // è§£æå‘½ä»¤è¡Œå‚æ•°
    flag.Parse()

    // è·å–éé€‰é¡¹å‚æ•°
    args := flag.Args()

    // ä½¿ç”¨å‚æ•°
    fmt.Printf("æœåŠ¡å™¨å°†åœ¨ %s:%d å¯åŠ¨\n", *host, *port)
    fmt.Printf("è°ƒè¯•æ¨¡å¼: %v\n", *debug)
    fmt.Printf("è¶…æ—¶æ—¶é—´: %v\n", *timeout)
    fmt.Printf("é…ç½®æ–‡ä»¶: %s\n", *config)
    fmt.Printf("å…¶ä»–å‚æ•°: %v\n", args)
}
```





### è‡ªå®šä¹‰ flag ç±»

```go
package main

import (
    "flag"
    "fmt"
    "strings"
)

// è‡ªå®šä¹‰åˆ‡ç‰‡ç±»å‹
type StringSlice []string

func (s *StringSlice) String() string {
    return strings.Join(*s, ",")
}

func (s *StringSlice) Set(value string) error {
    *s = append(*s, value)
    return nil
}

// è‡ªå®šä¹‰æ˜ å°„ç±»å‹
type StringMap map[string]string

func (m *StringMap) String() string {
    var pairs []string
    for k, v := range *m {
        pairs = append(pairs, fmt.Sprintf("%s=%s", k, v))
    }
    return strings.Join(pairs, ",")
}

func (m *StringMap) Set(value string) error {
    if *m == nil {
        *m = make(map[string]string)
    }
    
    parts := strings.SplitN(value, "=", 2)
    if len(parts) != 2 {
        return fmt.Errorf("æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º key=value")
    }
    
    (*m)[parts[0]] = parts[1]
    return nil
}

func main() {
    var (
        tags     StringSlice
        metadata StringMap = make(StringMap)
    )

    flag.Var(&tags, "tag", "æ·»åŠ æ ‡ç­¾ (å¯é‡å¤ä½¿ç”¨)")
    flag.Var(&metadata, "meta", "æ·»åŠ å…ƒæ•°æ® key=value (å¯é‡å¤ä½¿ç”¨)")

    flag.Parse()

    fmt.Printf("æ ‡ç­¾: %v\n", tags)
    fmt.Printf("å…ƒæ•°æ®: %v\n", metadata)
}
```

### å­å‘½ä»¤å¤„ç†

```go
package main

import (
    "flag"
    "fmt"
    "os"
)

func main() {
    if len(os.Args) < 2 {
        fmt.Println("ç”¨æ³•: program <command> [options]")
        fmt.Println("å‘½ä»¤:")
        fmt.Println("  start   å¯åŠ¨æœåŠ¡")
        fmt.Println("  stop    åœæ­¢æœåŠ¡")
        fmt.Println("  status  æŸ¥çœ‹çŠ¶æ€")
        os.Exit(1)
    }

    switch os.Args[1] {
    case "start":
        startCmd()
    case "stop":
        stopCmd()
    case "status":
        statusCmd()
    default:
        fmt.Printf("æœªçŸ¥å‘½ä»¤: %s\n", os.Args[1])
        os.Exit(1)
    }
}

func startCmd() {
    startFlags := flag.NewFlagSet("start", flag.ExitOnError)
    port := startFlags.Int("port", 8080, "ç«¯å£å·")
    daemon := startFlags.Bool("daemon", false, "åå°è¿è¡Œ")
    
    startFlags.Parse(os.Args[2:])
    
    fmt.Printf("å¯åŠ¨æœåŠ¡ï¼Œç«¯å£: %d, åå°è¿è¡Œ: %v\n", *port, *daemon)
}

func stopCmd() {
    stopFlags := flag.NewFlagSet("stop", flag.ExitOnError)
    force := stopFlags.Bool("force", false, "å¼ºåˆ¶åœæ­¢")
    
    stopFlags.Parse(os.Args[2:])
    
    fmt.Printf("åœæ­¢æœåŠ¡ï¼Œå¼ºåˆ¶åœæ­¢: %v\n", *force)
}

func statusCmd() {
    fmt.Println("æœåŠ¡çŠ¶æ€: è¿è¡Œä¸­")
}
```

### ç¬¬ä¸‰æ–¹å‘½ä»¤è¡Œåº“ - cobra

```go
// go get github.com/spf13/cobra
package main

import (
    "fmt"
    "github.com/spf13/cobra"
    "os"
)

var (
    verbose bool
    config  string
)

var rootCmd = &cobra.Command{
    Use:   "myapp",
    Short: "æˆ‘çš„åº”ç”¨ç¨‹åº",
    Long:  "è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹åº”ç”¨ç¨‹åºï¼Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨ cobra",
}

var startCmd = &cobra.Command{
    Use:   "start",
    Short: "å¯åŠ¨æœåŠ¡",
    Run: func(cmd *cobra.Command, args []string) {
        port, _ := cmd.Flags().GetInt("port")
        fmt.Printf("å¯åŠ¨æœåŠ¡ï¼Œç«¯å£: %d\n", port)
        if verbose {
            fmt.Println("è¯¦ç»†æ¨¡å¼å·²å¯ç”¨")
        }
    },
}

func init() {
    // å…¨å±€æ ‡å¿—
    rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "è¯¦ç»†è¾“å‡º")
    rootCmd.PersistentFlags().StringVar(&config, "config", "", "é…ç½®æ–‡ä»¶è·¯å¾„")

    // å­å‘½ä»¤æ ‡å¿—
    startCmd.Flags().IntP("port", "p", 8080, "æœåŠ¡ç«¯å£")
    
    rootCmd.AddCommand(startCmd)
}

func main() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
}
```



## ç¯å¢ƒå˜é‡ç®¡ç†ä¸é…ç½®æ¨¡å¼



### åŸºç¡€ç¯å¢ƒå˜é‡å¤„ç†

```go
package main

import (
    "fmt"
    "os"
    "strconv"
    "strings"
    "time"
)

type Config struct {
    Port        int           `env:"PORT" default:"8080"`
    Host        string        `env:"HOST" default:"localhost"`
    Debug       bool          `env:"DEBUG" default:"false"`
    Timeout     time.Duration `env:"TIMEOUT" default:"30s"`
    DatabaseURL string        `env:"DATABASE_URL" required:"true"`
    Features    []string      `env:"FEATURES" separator:","`
}

func main() {
    config := &Config{}
    
    // æ‰‹åŠ¨è§£æç¯å¢ƒå˜é‡
    if port := os.Getenv("PORT"); port != "" {
        if p, err := strconv.Atoi(port); err == nil {
            config.Port = p
        }
    } else {
        config.Port = 8080
    }

    config.Host = getEnvWithDefault("HOST", "localhost")
    config.Debug = getEnvAsBool("DEBUG", false)
    config.Timeout = getEnvAsDuration("TIMEOUT", 30*time.Second)
    config.DatabaseURL = getEnvRequired("DATABASE_URL")
    config.Features = getEnvAsSlice("FEATURES", []string{})

    fmt.Printf("é…ç½®: %+v\n", config)
}

func getEnvWithDefault(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvAsBool(key string, defaultValue bool) bool {
    if value := os.Getenv(key); value != "" {
        if b, err := strconv.ParseBool(value); err == nil {
            return b
        }
    }
    return defaultValue
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration {
    if value := os.Getenv(key); value != "" {
        if d, err := time.ParseDuration(value); err == nil {
            return d
        }
    }
    return defaultValue
}

func getEnvRequired(key string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    panic(fmt.Sprintf("ç¯å¢ƒå˜é‡ %s æ˜¯å¿…éœ€çš„", key))
}

func getEnvAsSlice(key string, defaultValue []string) []string {
    if value := os.Getenv(key); value != "" {
        return strings.Split(value, ",")
    }
    return defaultValue
}
```



### ä½¿ç”¨ godotenv åŠ è½½ .env æ–‡ä»¶

```go
// go get github.com/joho/godotenv
package main

import (
    "fmt"
    "log"
    "os"
    
    "github.com/joho/godotenv"
)

func main() {
    // åŠ è½½ .env æ–‡ä»¶
    if err := godotenv.Load(); err != nil {
        log.Println("æ²¡æœ‰æ‰¾åˆ° .env æ–‡ä»¶")
    }

    // æ”¯æŒå¤šä¸ªç¯å¢ƒæ–‡ä»¶
    err := godotenv.Load(
        ".env.local",
        ".env",
    )
    if err != nil {
        log.Println("åŠ è½½ç¯å¢ƒæ–‡ä»¶å¤±è´¥:", err)
    }

    // ä½¿ç”¨ç¯å¢ƒå˜é‡
    port := os.Getenv("PORT")
    dbURL := os.Getenv("DATABASE_URL")
    
    fmt.Printf("ç«¯å£: %s\n", port)
    fmt.Printf("æ•°æ®åº“: %s\n", dbURL)
}
```



### ç¯å¢ƒå˜é‡è‡ªåŠ¨æ˜ å°„

```go
// go get github.com/caarlos0/env/v6
package main

import (
    "fmt"
    "log"
    "time"
    
    "github.com/caarlos0/env/v6"
)

type Config struct {
    Home         string        `env:"HOME"`
    Port         int           `env:"PORT" envDefault:"8080"`
    Password     string        `env:"PASSWORD,unset"`
    IsProduction bool          `env:"PRODUCTION"`
    Hosts        []string      `env:"HOSTS" envSeparator:","`
    Duration     time.Duration `env:"DURATION"`
    TempFolder   string        `env:"TEMP_FOLDER" envDefault:"${HOME}/tmp" envExpand:"true"`
}

func main() {
    cfg := Config{}
    if err := env.Parse(&cfg); err != nil {
        log.Fatalf("è§£æç¯å¢ƒå˜é‡å¤±è´¥: %v", err)
    }

    fmt.Printf("%+v\n", cfg)
}
```



##  é…ç½®æ–‡ä»¶è¯»å–ä¸è§£æ

### YAML é…ç½®æ–‡ä»¶å¤„ç†

```go
// go get gopkg.in/yaml.v3
package main

import (
    "fmt"
    "io/ioutil"
    "log"
    "time"
    
    "gopkg.in/yaml.v3"
)

type DatabaseConfig struct {
    Host     string `yaml:"host"`
    Port     int    `yaml:"port"`
    Username string `yaml:"username"`
    Password string `yaml:"password"`
    Database string `yaml:"database"`
    SSLMode  string `yaml:"ssl_mode"`
}

type ServerConfig struct {
    Host         string        `yaml:"host"`
    Port         int           `yaml:"port"`
    ReadTimeout  time.Duration `yaml:"read_timeout"`
    WriteTimeout time.Duration `yaml:"write_timeout"`
}

type LogConfig struct {
    Level  string `yaml:"level"`
    Format string `yaml:"format"`
    Output string `yaml:"output"`
}

type Config struct {
    Environment string          `yaml:"environment"`
    Server      ServerConfig    `yaml:"server"`
    Database    DatabaseConfig  `yaml:"database"`
    Log         LogConfig       `yaml:"log"`
    Features    map[string]bool `yaml:"features"`
}

func LoadConfig(filename string) (*Config, error) {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥: %w", err)
    }

    var config Config
    if err := yaml.Unmarshal(data, &config); err != nil {
        return nil, fmt.Errorf("è§£æYAMLå¤±è´¥: %w", err)
    }

    return &config, nil
}

func main() {
    config, err := LoadConfig("config.yaml")
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("é…ç½®: %+v\n", config)
}
```



### JSON é…ç½®æ–‡ä»¶å¤„ç†

```go
package main

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "log"
)

type Config struct {
    Server struct {
        Host string `json:"host"`
        Port int    `json:"port"`
    } `json:"server"`
    
    Database struct {
        Driver string `json:"driver"`
        DSN    string `json:"dsn"`
    } `json:"database"`
    
    Redis struct {
        Addr     string `json:"addr"`
        Password string `json:"password"`
        DB       int    `json:"db"`
    } `json:"redis"`
    
    Logging struct {
        Level string `json:"level"`
        File  string `json:"file"`
    } `json:"logging"`
}

func LoadJSONConfig(filename string) (*Config, error) {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, err
    }

    var config Config
    if err := json.Unmarshal(data, &config); err != nil {
        return nil, err
    }

    return &config, nil
}

func main() {
    config, err := LoadJSONConfig("config.json")
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("æœåŠ¡å™¨: %s:%d\n", config.Server.Host, config.Server.Port)
    fmt.Printf("æ•°æ®åº“: %s\n", config.Database.DSN)
}
```



### TOML é…ç½®æ–‡ä»¶å¤„ç†

```go
// go get github.com/BurntSushi/toml
package main

import (
    "fmt"
    "log"
    
    "github.com/BurntSushi/toml"
)

type Config struct {
    Title   string
    Owner   Owner
    DB      Database `toml:"database"`
    Servers map[string]Server
}

type Owner struct {
    Name string
    Org  string `toml:"organization"`
    Bio  string
    DOB  string
}

type Database struct {
    Server  string
    Ports   []int
    ConnMax int `toml:"connection_max"`
    Enabled bool
}

type Server struct {
    IP string
    DC string
}

func main() {
    var config Config
    if _, err := toml.DecodeFile("config.toml", &config); err != nil {
        log.Fatal(err)
    }

    fmt.Printf("æ ‡é¢˜: %s\n", config.Title)
    fmt.Printf("æ‹¥æœ‰è€…: %s (%s)\n", config.Owner.Name, config.Owner.Org)
    fmt.Printf("æ•°æ®åº“æœåŠ¡å™¨: %s\n", config.DB.Server)
    fmt.Printf("æœåŠ¡å™¨åˆ—è¡¨: %+v\n", config.Servers)
}
```



### ä½¿ç”¨ Viper ç»Ÿä¸€é…ç½®ç®¡ç†

```go
// go get github.com/spf13/viper
package main

import (
    "fmt"
    "log"
    
    "github.com/spf13/viper"
)

func main() {
    // è®¾ç½®é…ç½®æ–‡ä»¶ä¿¡æ¯
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")
    viper.AddConfigPath("./configs")
    viper.AddConfigPath(".")

    // è®¾ç½®ç¯å¢ƒå˜é‡å‰ç¼€
    viper.SetEnvPrefix("MYAPP")
    viper.AutomaticEnv()

    // è®¾ç½®é»˜è®¤å€¼
    viper.SetDefault("server.port", 8080)
    viper.SetDefault("server.host", "localhost")
    viper.SetDefault("log.level", "info")

    // è¯»å–é…ç½®æ–‡ä»¶
    if err := viper.ReadInConfig(); err != nil {
        log.Printf("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥: %v", err)
    }

    // ç›‘å¬é…ç½®æ–‡ä»¶å˜åŒ–
    viper.WatchConfig()
    viper.OnConfigChange(func(e fsnotify.Event) {
        fmt.Println("é…ç½®æ–‡ä»¶å·²æ›´æ”¹:", e.Name)
    })

    // ä½¿ç”¨é…ç½®
    fmt.Printf("æœåŠ¡å™¨ç«¯å£: %d\n", viper.GetInt("server.port"))
    fmt.Printf("æ•°æ®åº“URL: %s\n", viper.GetString("database.url"))
    fmt.Printf("å¯ç”¨åŠŸèƒ½: %v\n", viper.GetStringSlice("enabled_features"))

    // ç»‘å®šåˆ°ç»“æ„ä½“
    var config Config
    if err := viper.Unmarshal(&config); err != nil {
        log.Fatal("é…ç½®è§£æå¤±è´¥:", err)
    }
}
```



## åŸºäºç¯å¢ƒçš„é…ç½®åˆ‡æ¢



### é…ç½®å±‚æ¬¡ç»“æ„

```go
package config

import (
    "fmt"
    "os"
    "path/filepath"
    
    "github.com/spf13/viper"
)

type Config struct {
    Environment string `mapstructure:"environment"`
    
    Server struct {
        Host string `mapstructure:"host"`
        Port int    `mapstructure:"port"`
    } `mapstructure:"server"`
    
    Database struct {
        Host     string `mapstructure:"host"`
        Port     int    `mapstructure:"port"`
        Username string `mapstructure:"username"`
        Password string `mapstructure:"password"`
        Database string `mapstructure:"database"`
    } `mapstructure:"database"`
    
    Redis struct {
        Addr     string `mapstructure:"addr"`
        Password string `mapstructure:"password"`
    } `mapstructure:"redis"`
    
    Log struct {
        Level string `mapstructure:"level"`
        File  string `mapstructure:"file"`
    } `mapstructure:"log"`
}

func Load() (*Config, error) {
    v := viper.New()
    
    // è·å–ç¯å¢ƒ
    env := os.Getenv("GO_ENV")
    if env == "" {
        env = "development"
    }

    // é…ç½®æ–‡ä»¶æœç´¢è·¯å¾„
    v.AddConfigPath("./configs")
    v.AddConfigPath(".")

    // åŠ è½½åŸºç¡€é…ç½®
    v.SetConfigName("config")
    if err := v.ReadInConfig(); err != nil {
        return nil, fmt.Errorf("è¯»å–åŸºç¡€é…ç½®å¤±è´¥: %w", err)
    }

    // åŠ è½½ç¯å¢ƒç‰¹å®šé…ç½®
    v.SetConfigName(fmt.Sprintf("config.%s", env))
    if err := v.MergeInConfig(); err != nil {
        // ç¯å¢ƒé…ç½®æ–‡ä»¶ä¸å­˜åœ¨æ—¶ä¸æŠ¥é”™
        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
            return nil, fmt.Errorf("è¯»å–ç¯å¢ƒé…ç½®å¤±è´¥: %w", err)
        }
    }

    // åŠ è½½æœ¬åœ°é…ç½®ï¼ˆä¸åº”æäº¤åˆ°ç‰ˆæœ¬æ§åˆ¶ï¼‰
    v.SetConfigName("config.local")
    if err := v.MergeInConfig(); err != nil {
        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
            return nil, fmt.Errorf("è¯»å–æœ¬åœ°é…ç½®å¤±è´¥: %w", err)
        }
    }

    // ç¯å¢ƒå˜é‡è¦†ç›–
    v.SetEnvPrefix("MYAPP")
    v.AutomaticEnv()

    // è§£æåˆ°ç»“æ„ä½“
    var config Config
    if err := v.Unmarshal(&config); err != nil {
        return nil, fmt.Errorf("é…ç½®è§£æå¤±è´¥: %w", err)
    }

    config.Environment = env
    return &config, nil
}
```



### é…ç½®æ–‡ä»¶ç»“æ„ç¤ºä¾‹

```yaml
# config.yaml (åŸºç¡€é…ç½®)
server:
  host: "0.0.0.0"
  port: 8080

database:
  host: "localhost"
  port: 5432
  username: "postgres"
  database: "myapp"

log:
  level: "info"
  format: "json"

---
# config.development.yaml (å¼€å‘ç¯å¢ƒ)
database:
  password: "dev_password"
  
log:
  level: "debug"
  format: "text"

redis:
  addr: "localhost:6379"

---
# config.production.yaml (ç”Ÿäº§ç¯å¢ƒ)
server:
  host: "0.0.0.0"
  port: 80

database:
  host: "prod-db.example.com"
  ssl_mode: "require"

log:
  level: "warn"
  file: "/var/log/myapp.log"

redis:
  addr: "redis-cluster.example.com:6379"
  password: "${REDIS_PASSWORD}"
```



### å¤šç¯å¢ƒé…ç½®ç®¡ç†å™¨

```go
package config

import (
    "fmt"
    "os"
    "sync"
)

type Manager struct {
    configs map[string]*Config
    current string
    mu      sync.RWMutex
}

var (
    instance *Manager
    once     sync.Once
)

func GetManager() *Manager {
    once.Do(func() {
        instance = &Manager{
            configs: make(map[string]*Config),
            current: getEnvironment(),
        }
    })
    return instance
}

func (m *Manager) LoadEnvironment(env string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    config, err := loadConfigForEnv(env)
    if err != nil {
        return fmt.Errorf("åŠ è½½ç¯å¢ƒ %s çš„é…ç½®å¤±è´¥: %w", env, err)
    }

    m.configs[env] = config
    return nil
}

func (m *Manager) SwitchEnvironment(env string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    if _, exists := m.configs[env]; !exists {
        if err := m.LoadEnvironment(env); err != nil {
            return err
        }
    }

    m.current = env
    return nil
}

func (m *Manager) GetConfig() *Config {
    m.mu.RLock()
    defer m.mu.RUnlock()

    if config, exists := m.configs[m.current]; exists {
        return config
    }

    // å¦‚æœå½“å‰ç¯å¢ƒé…ç½®ä¸å­˜åœ¨ï¼Œå°è¯•åŠ è½½
    if err := m.LoadEnvironment(m.current); err != nil {
        panic(fmt.Sprintf("æ— æ³•åŠ è½½å½“å‰ç¯å¢ƒé…ç½®: %v", err))
    }

    return m.configs[m.current]
}

func (m *Manager) GetEnvironment() string {
    m.mu.RLock()
    defer m.mu.RUnlock()
    return m.current
}

func getEnvironment() string {
    env := os.Getenv("GO_ENV")
    if env == "" {
        env = "development"
    }
    return env
}

func loadConfigForEnv(env string) (*Config, error) {
    // è¿™é‡Œå®ç°å…·ä½“çš„é…ç½®åŠ è½½é€»è¾‘
    // å¯ä»¥æ ¹æ®ç¯å¢ƒåŠ è½½ä¸åŒçš„é…ç½®æ–‡ä»¶
    return Load() // ä½¿ç”¨ä¹‹å‰å®šä¹‰çš„Loadå‡½æ•°
}

// ä¾¿åˆ©å‡½æ•°
func Get() *Config {
    return GetManager().GetConfig()
}

func Switch(env string) error {
    return GetManager().SwitchEnvironment(env)
}
```



## æ•æ„Ÿä¿¡æ¯ç®¡ç†ä¸å®‰å…¨æ€§

### å¯†é’¥ç®¡ç†åŸºç¡€

```go
package security

import (
    "crypto/rand"
    "crypto/subtle"
    "encoding/base64"
    "fmt"
    "os"
    "strings"
)

type SecretManager struct {
    encryptionKey []byte
}

func NewSecretManager() (*SecretManager, error) {
    key := os.Getenv("ENCRYPTION_KEY")
    if key == "" {
        return nil, fmt.Errorf("ENCRYPTION_KEY ç¯å¢ƒå˜é‡æœªè®¾ç½®")
    }

    keyBytes, err := base64.StdEncoding.DecodeString(key)
    if err != nil {
        return nil, fmt.Errorf("è§£ç åŠ å¯†å¯†é’¥å¤±è´¥: %w", err)
    }

    return &SecretManager{
        encryptionKey: keyBytes,
    }, nil
}

// ç”Ÿæˆéšæœºå¯†é’¥
func GenerateKey() (string, error) {
    key := make([]byte, 32) // 256-bit key
    if _, err := rand.Read(key); err != nil {
        return "", err
    }
    return base64.StdEncoding.EncodeToString(key), nil
}

// å®‰å…¨æ¯”è¾ƒå¯†é’¥
func SecureCompare(a, b string) bool {
    return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}

// ä»ç¯å¢ƒå˜é‡å®‰å…¨è·å–å¯†é’¥
func GetSecretFromEnv(key string) (string, error) {
    value := os.Getenv(key)
    if value == "" {
        return "", fmt.Errorf("ç¯å¢ƒå˜é‡ %s æœªè®¾ç½®", key)
    }

    // æ¸…ç†ç¯å¢ƒå˜é‡ï¼ˆå¯é€‰ï¼‰
    os.Unsetenv(key)
    
    return value, nil
}

// è§£æå¸¦å‰ç¼€çš„å¯†é’¥å¼•ç”¨
func ResolveSecret(value string) (string, error) {
    if !strings.HasPrefix(value, "secret://") {
        return value, nil
    }

    secretName := strings.TrimPrefix(value, "secret://")
    return GetSecretFromEnv(secretName)
}
```



### é…ç½®ä¸­çš„å¯†é’¥å¤„ç†

```go
package config

import (
    "fmt"
    "reflect"
    "strings"
)

type SecretConfig struct {
    DatabasePassword string `config:"database_password" secret:"true"`
    APIKey          string `config:"api_key" secret:"true"`
    JWTSecret       string `config:"jwt_secret" secret:"true"`
    RedisPassword   string `config:"redis_password" secret:"true"`
}

func ProcessSecrets(config interface{}) error {
    v := reflect.ValueOf(config)
    if v.Kind() == reflect.Ptr {
        v = v.Elem()
    }

    return processStructSecrets(v)
}

func processStructSecrets(v reflect.Value) error {
    t := v.Type()

    for i := 0; i < v.NumField(); i++ {
        field := v.Field(i)
        fieldType := t.Field(i)

        // æ£€æŸ¥æ˜¯å¦æ ‡è®°ä¸ºå¯†é’¥
        if secretTag := fieldType.Tag.Get("secret"); secretTag == "true" {
            if field.Kind() == reflect.String && field.CanSet() {
                originalValue := field.String()
                resolvedValue, err := ResolveSecret(originalValue)
                if err != nil {
                    return fmt.Errorf("è§£æå¯†é’¥ %s å¤±è´¥: %w", fieldType.Name, err)
                }
                field.SetString(resolvedValue)
            }
        }

        // é€’å½’å¤„ç†åµŒå¥—ç»“æ„
        if field.Kind() == reflect.Struct {
            if err := processStructSecrets(field); err != nil {
                return err
            }
        }
    }

    return nil
}

// æ•æ„Ÿä¿¡æ¯æ©ç 
func MaskSensitiveData(config interface{}) interface{} {
    v := reflect.ValueOf(config)
    if v.Kind() == reflect.Ptr {
        v = v.Elem()
    }

    return maskStruct(v).Interface()
}

func maskStruct(v reflect.Value) reflect.Value {
    t := v.Type()
    newStruct := reflect.New(t).Elem()

    for i := 0; i < v.NumField(); i++ {
        field := v.Field(i)
        fieldType := t.Field(i)
        newField := newStruct.Field(i)

        if secretTag := fieldType.Tag.Get("secret"); secretTag == "true" {
            if field.Kind() == reflect.String {
                masked := maskString(field.String())
                newField.SetString(masked)
                continue
            }
        }

        if field.Kind() == reflect.Struct {
            newField.Set(maskStruct(field))
        } else if field.CanSet() {
            newField.Set(field)
        }
    }

    return newStruct
}

func maskString(s string) string {
    if len(s) <= 4 {
        return "****"
    }
    return s[:2] + strings.Repeat("*", len(s)-4) + s[len(s)-2:]
}
```



# Goè¯­è¨€ç›‘æ§ä¸å¯è§‚æµ‹æ€§

## åŸºç¡€æ—¥å¿—è®°å½•ä¸ log åŒ…ä½¿ç”¨

### 1.1 æ ‡å‡†åº“ log åŒ…åŸºç¡€

Go æ ‡å‡†åº“çš„ `log` åŒ…æä¾›äº†åŸºæœ¬çš„æ—¥å¿—åŠŸèƒ½ï¼š

```go
package main

import (
    "log"
    "os"
)

func main() {
    // åŸºæœ¬æ—¥å¿—è¾“å‡º
    log.Println("è¿™æ˜¯ä¸€æ¡ä¿¡æ¯æ—¥å¿—")
    log.Printf("ç”¨æˆ· %s ç™»å½•æˆåŠŸ", "alice")
    
    // è®¾ç½®æ—¥å¿—å‰ç¼€
    log.SetPrefix("[APP] ")
    log.Println("å¸¦å‰ç¼€çš„æ—¥å¿—")
    
    // è®¾ç½®æ—¥å¿—æ ‡å¿—
    log.SetFlags(log.LstdFlags | log.Lshortfile)
    log.Println("å¸¦æ—¶é—´å’Œæ–‡ä»¶ä¿¡æ¯çš„æ—¥å¿—")
    
    // è‡´å‘½é”™è¯¯æ—¥å¿—ï¼ˆä¼šé€€å‡ºç¨‹åºï¼‰
    // log.Fatal("è‡´å‘½é”™è¯¯ï¼Œç¨‹åºé€€å‡º")
    
    // ææ…Œæ—¥å¿—ï¼ˆä¼šè§¦å‘ panicï¼‰
    // log.Panic("è§¦å‘ panic")
}
```

### 1.2 è‡ªå®šä¹‰æ—¥å¿—å™¨

```go
package main

import (
    "io"
    "log"
    "os"
)

func main() {
    // åˆ›å»ºæ—¥å¿—æ–‡ä»¶
    file, err := os.OpenFile("app.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        log.Fatal("æ— æ³•åˆ›å»ºæ—¥å¿—æ–‡ä»¶:", err)
    }
    defer file.Close()
    
    // åˆ›å»ºå¤šè¾“å‡ºæ—¥å¿—å™¨
    multiWriter := io.MultiWriter(os.Stdout, file)
    logger := log.New(multiWriter, "[CUSTOM] ", log.LstdFlags|log.Lshortfile)
    
    logger.Println("è¿™æ¡æ—¥å¿—ä¼šåŒæ—¶è¾“å‡ºåˆ°æ§åˆ¶å°å’Œæ–‡ä»¶")
    
    // ä¸åŒçº§åˆ«çš„æ—¥å¿—å™¨
    infoLogger := log.New(multiWriter, "[INFO] ", log.LstdFlags)
    errorLogger := log.New(multiWriter, "[ERROR] ", log.LstdFlags|log.Lshortfile)
    
    infoLogger.Println("ä¿¡æ¯æ—¥å¿—")
    errorLogger.Println("é”™è¯¯æ—¥å¿—")
}
```

### 1.3 æ—¥å¿—è½®è½¬å®ç°

```go
package main

import (
    "fmt"
    "log"
    "os"
    "path/filepath"
    "time"
)

type RotatingLogger struct {
    filename string
    maxSize  int64
    logger   *log.Logger
    file     *os.File
}

func NewRotatingLogger(filename string, maxSize int64) (*RotatingLogger, error) {
    rl := &RotatingLogger{
        filename: filename,
        maxSize:  maxSize,
    }
    
    if err := rl.openFile(); err != nil {
        return nil, err
    }
    
    return rl, nil
}

func (rl *RotatingLogger) openFile() error {
    file, err := os.OpenFile(rl.filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        return err
    }
    
    rl.file = file
    rl.logger = log.New(file, "", log.LstdFlags)
    
    return nil
}

func (rl *RotatingLogger) Log(message string) error {
    // æ£€æŸ¥æ–‡ä»¶å¤§å°
    if stat, err := rl.file.Stat(); err == nil {
        if stat.Size() > rl.maxSize {
            if err := rl.rotate(); err != nil {
                return err
            }
        }
    }
    
    rl.logger.Println(message)
    return nil
}

func (rl *RotatingLogger) rotate() error {
    rl.file.Close()
    
    // é‡å‘½åå½“å‰æ–‡ä»¶
    timestamp := time.Now().Format("20060102-150405")
    oldName := rl.filename
    newName := fmt.Sprintf("%s.%s", rl.filename, timestamp)
    
    if err := os.Rename(oldName, newName); err != nil {
        return err
    }
    
    // åˆ›å»ºæ–°æ–‡ä»¶
    return rl.openFile()
}

func (rl *RotatingLogger) Close() error {
    if rl.file != nil {
        return rl.file.Close()
    }
    return nil
}
```



## ç»“æ„åŒ–æ—¥å¿—ä¸æ—¥å¿—çº§åˆ«

### 2.1 ä½¿ç”¨ logrus å®ç°ç»“æ„åŒ–æ—¥å¿—

```go
package main

import (
    "github.com/sirupsen/logrus"
    "os"
)

func main() {
    // è®¾ç½®æ—¥å¿—æ ¼å¼ä¸º JSON
    logrus.SetFormatter(&logrus.JSONFormatter{})
    
    // è®¾ç½®æ—¥å¿—çº§åˆ«
    logrus.SetLevel(logrus.DebugLevel)
    
    // è®¾ç½®è¾“å‡ºåˆ°æ–‡ä»¶
    file, err := os.OpenFile("structured.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err == nil {
        logrus.SetOutput(file)
        defer file.Close()
    }
    
    // ç»“æ„åŒ–æ—¥å¿—è®°å½•
    logrus.WithFields(logrus.Fields{
        "user_id":   12345,
        "action":    "login",
        "ip":        "192.168.1.100",
        "timestamp": "2024-01-15T10:30:00Z",
    }).Info("ç”¨æˆ·ç™»å½•æˆåŠŸ")
    
    logrus.WithFields(logrus.Fields{
        "error":     "database connection failed",
        "host":      "db.example.com",
        "port":      5432,
        "retry_count": 3,
    }).Error("æ•°æ®åº“è¿æ¥å¤±è´¥")
    
    // ä¸åŒçº§åˆ«çš„æ—¥å¿—
    logrus.Debug("è°ƒè¯•ä¿¡æ¯")
    logrus.Info("ä¸€èˆ¬ä¿¡æ¯")
    logrus.Warn("è­¦å‘Šä¿¡æ¯")
    logrus.Error("é”™è¯¯ä¿¡æ¯")
}
```

### 2.2 è‡ªå®šä¹‰æ—¥å¿—ä¸­é—´ä»¶

```go
package main

import (
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/sirupsen/logrus"
)

// HTTP è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶
func LoggerMiddleware() gin.HandlerFunc {
    return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
        logrus.WithFields(logrus.Fields{
            "timestamp":   param.TimeStamp.Format("2006/01/02 - 15:04:05"),
            "method":      param.Method,
            "path":        param.Path,
            "status_code": param.StatusCode,
            "latency":     param.Latency,
            "client_ip":   param.ClientIP,
            "user_agent":  param.ClientUserAgent,
            "error":       param.ErrorMessage,
        }).Info("HTTP Request")
        
        return ""
    })
}

// ç»“æ„åŒ–é”™è¯¯æ—¥å¿—
func LogError(err error, context map[string]interface{}) {
    fields := logrus.Fields{
        "error": err.Error(),
        "time":  time.Now(),
    }
    
    for k, v := range context {
        fields[k] = v
    }
    
    logrus.WithFields(fields).Error("åº”ç”¨é”™è¯¯")
}

// ä¸šåŠ¡æ—¥å¿—è®°å½•å™¨
type BusinessLogger struct {
    logger *logrus.Logger
}

func NewBusinessLogger() *BusinessLogger {
    logger := logrus.New()
    logger.SetFormatter(&logrus.JSONFormatter{})
    
    return &BusinessLogger{logger: logger}
}

func (bl *BusinessLogger) LogUserAction(userID int, action string, details map[string]interface{}) {
    fields := logrus.Fields{
        "user_id": userID,
        "action":  action,
        "time":    time.Now(),
    }
    
    for k, v := range details {
        fields[k] = v
    }
    
    bl.logger.WithFields(fields).Info("ç”¨æˆ·è¡Œä¸º")
}

func (bl *BusinessLogger) LogSystemEvent(event string, severity string, details map[string]interface{}) {
    fields := logrus.Fields{
        "event":    event,
        "severity": severity,
        "time":     time.Now(),
    }
    
    for k, v := range details {
        fields[k] = v
    }
    
    bl.logger.WithFields(fields).Info("ç³»ç»Ÿäº‹ä»¶")
}
```

### 2.3 æ—¥å¿—èšåˆä¸åˆ†æ

```go
package main

import (
    "bufio"
    "encoding/json"
    "fmt"
    "os"
    "strings"
    "time"
)

// æ—¥å¿—æ¡ç›®ç»“æ„
type LogEntry struct {
    Timestamp time.Time              `json:"time"`
    Level     string                 `json:"level"`
    Message   string                 `json:"msg"`
    Fields    map[string]interface{} `json:",inline"`
}

// æ—¥å¿—åˆ†æå™¨
type LogAnalyzer struct {
    entries []LogEntry
}

func NewLogAnalyzer() *LogAnalyzer {
    return &LogAnalyzer{
        entries: make([]LogEntry, 0),
    }
}

func (la *LogAnalyzer) LoadFromFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()
    
    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        line := scanner.Text()
        var entry LogEntry
        if err := json.Unmarshal([]byte(line), &entry); err == nil {
            la.entries = append(la.entries, entry)
        }
    }
    
    return scanner.Err()
}

func (la *LogAnalyzer) GetErrorSummary() map[string]int {
    summary := make(map[string]int)
    
    for _, entry := range la.entries {
        if strings.ToLower(entry.Level) == "error" {
            summary[entry.Message]++
        }
    }
    
    return summary
}

func (la *LogAnalyzer) GetHourlyStats() map[int]int {
    stats := make(map[int]int)
    
    for _, entry := range la.entries {
        hour := entry.Timestamp.Hour()
        stats[hour]++
    }
    
    return stats
}

func (la *LogAnalyzer) PrintSummary() {
    fmt.Printf("æ€»æ—¥å¿—æ¡æ•°: %d\n", len(la.entries))
    
    errorSummary := la.GetErrorSummary()
    fmt.Println("\né”™è¯¯ç»Ÿè®¡:")
    for msg, count := range errorSummary {
        fmt.Printf("  %s: %dæ¬¡\n", msg, count)
    }
    
    hourlyStats := la.GetHourlyStats()
    fmt.Println("\næŒ‰å°æ—¶ç»Ÿè®¡:")
    for hour := 0; hour < 24; hour++ {
        if count, exists := hourlyStats[hour]; exists {
            fmt.Printf("  %02d:00 - %dæ¡\n", hour, count)
        }
    }
}
```



##  ä½¿ç”¨ Prometheus è¿›è¡ŒæŒ‡æ ‡æ”¶é›†

### 3.1 åŸºç¡€ Prometheus é›†æˆ

```go
package main

import (
    "net/http"
    "time"
    
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
    // è®¡æ•°å™¨ - è®°å½•æ€»æ•°
    requestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "HTTPè¯·æ±‚æ€»æ•°",
        },
        []string{"method", "endpoint", "status"},
    )
    
    // ç›´æ–¹å›¾ - è®°å½•å“åº”æ—¶é—´åˆ†å¸ƒ
    requestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTPè¯·æ±‚è€—æ—¶",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )
    
    // ä»ªè¡¨ - è®°å½•å½“å‰æ´»è·ƒè¿æ¥æ•°
    activeConnections = prometheus.NewGauge(
        prometheus.GaugeOpts{
            Name: "active_connections",
            Help: "å½“å‰æ´»è·ƒè¿æ¥æ•°",
        },
    )
    
    // æ‘˜è¦ - è®°å½•å“åº”å¤§å°åˆ†ä½æ•°
    responseSize = prometheus.NewSummaryVec(
        prometheus.SummaryOpts{
            Name:       "http_response_size_bytes",
            Help:       "HTTPå“åº”å¤§å°",
            Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
        },
        []string{"method", "endpoint"},
    )
)

func init() {
    // æ³¨å†ŒæŒ‡æ ‡
    prometheus.MustRegister(requestsTotal)
    prometheus.MustRegister(requestDuration)
    prometheus.MustRegister(activeConnections)
    prometheus.MustRegister(responseSize)
}

// Prometheus ä¸­é—´ä»¶
func PrometheusMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // å¢åŠ æ´»è·ƒè¿æ¥æ•°
        activeConnections.Inc()
        defer activeConnections.Dec()
        
        // åŒ…è£… ResponseWriter ä»¥è·å–çŠ¶æ€ç å’Œå“åº”å¤§å°
        wrapped := &responseWriter{ResponseWriter: w, statusCode: 200}
        
        next.ServeHTTP(wrapped, r)
        
        // è®°å½•æŒ‡æ ‡
        duration := time.Since(start).Seconds()
        status := string(wrapped.statusCode)
        
        requestsTotal.WithLabelValues(r.Method, r.URL.Path, status).Inc()
        requestDuration.WithLabelValues(r.Method, r.URL.Path).Observe(duration)
        responseSize.WithLabelValues(r.Method, r.URL.Path).Observe(float64(wrapped.size))
    })
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
    size       int
}

func (rw *responseWriter) WriteHeader(statusCode int) {
    rw.statusCode = statusCode
    rw.ResponseWriter.WriteHeader(statusCode)
}

func (rw *responseWriter) Write(b []byte) (int, error) {
    size, err := rw.ResponseWriter.Write(b)
    rw.size += size
    return size, err
}

func main() {
    // ä¸šåŠ¡è·¯ç”±
    http.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        time.Sleep(100 * time.Millisecond) // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"users": []}`))
    })
    
    // Prometheus æŒ‡æ ‡ç«¯ç‚¹
    http.Handle("/metrics", promhttp.Handler())
    
    // åº”ç”¨ä¸­é—´ä»¶
    handler := PrometheusMiddleware(http.DefaultServeMux)
    
    http.ListenAndServe(":8080", handler)
}
```

### 3.2 è‡ªå®šä¹‰ä¸šåŠ¡æŒ‡æ ‡

```go
package main

import (
    "context"
    "database/sql"
    "time"
    
    "github.com/prometheus/client_golang/prometheus"
)

// ä¸šåŠ¡æŒ‡æ ‡å®šä¹‰
var (
    // ç”¨æˆ·ç›¸å…³æŒ‡æ ‡
    userRegistrations = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "user_registrations_total",
            Help: "ç”¨æˆ·æ³¨å†Œæ€»æ•°",
        },
        []string{"source", "plan"},
    )
    
    userLogins = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "user_logins_total",
            Help: "ç”¨æˆ·ç™»å½•æ€»æ•°",
        },
        []string{"method"},
    )
    
    activeUsers = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "active_users",
            Help: "æ´»è·ƒç”¨æˆ·æ•°",
        },
        []string{"time_window"},
    )
    
    // è®¢å•ç›¸å…³æŒ‡æ ‡
    orderValue = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "order_value_dollars",
            Help:    "è®¢å•é‡‘é¢åˆ†å¸ƒ",
            Buckets: []float64{10, 50, 100, 500, 1000, 5000},
        },
        []string{"category"},
    )
    
    // ç³»ç»Ÿèµ„æºæŒ‡æ ‡
    databaseConnections = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "database_connections",
            Help: "æ•°æ®åº“è¿æ¥æ•°",
        },
        []string{"database", "state"},
    )
    
    cacheHitRate = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "cache_hit_rate",
            Help: "ç¼“å­˜å‘½ä¸­ç‡",
        },
        []string{"cache_name"},
    )
)

func init() {
    prometheus.MustRegister(userRegistrations, userLogins, activeUsers)
    prometheus.MustRegister(orderValue)
    prometheus.MustRegister(databaseConnections, cacheHitRate)
}

// ç”¨æˆ·æœåŠ¡æŒ‡æ ‡æ”¶é›†
type UserService struct {
    db *sql.DB
}

func (us *UserService) RegisterUser(source, plan string) error {
    // ä¸šåŠ¡é€»è¾‘...
    
    // è®°å½•æŒ‡æ ‡
    userRegistrations.WithLabelValues(source, plan).Inc()
    
    return nil
}

func (us *UserService) LoginUser(method string) error {
    // ä¸šåŠ¡é€»è¾‘...
    
    // è®°å½•æŒ‡æ ‡
    userLogins.WithLabelValues(method).Inc()
    
    return nil
}

// è®¢å•æœåŠ¡æŒ‡æ ‡æ”¶é›†
type OrderService struct{}

func (os *OrderService) CreateOrder(category string, value float64) error {
    // ä¸šåŠ¡é€»è¾‘...
    
    // è®°å½•æŒ‡æ ‡
    orderValue.WithLabelValues(category).Observe(value)
    
    return nil
}

// ç³»ç»Ÿç›‘æ§å™¨
type SystemMonitor struct {
    db *sql.DB
}

func (sm *SystemMonitor) Start(ctx context.Context) {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            sm.collectMetrics()
        }
    }
}

func (sm *SystemMonitor) collectMetrics() {
    // æ”¶é›†æ•°æ®åº“è¿æ¥æ•°
    stats := sm.db.Stats()
    databaseConnections.WithLabelValues("postgres", "open").Set(float64(stats.OpenConnections))
    databaseConnections.WithLabelValues("postgres", "idle").Set(float64(stats.Idle))
    databaseConnections.WithLabelValues("postgres", "in_use").Set(float64(stats.InUse))
    
    // æ”¶é›†æ´»è·ƒç”¨æˆ·æ•°ï¼ˆæ¨¡æ‹Ÿï¼‰
    activeUsers.WithLabelValues("5min").Set(float64(getUserCount("5min")))
    activeUsers.WithLabelValues("1hour").Set(float64(getUserCount("1hour")))
    activeUsers.WithLabelValues("24hour").Set(float64(getUserCount("24hour")))
    
    // æ”¶é›†ç¼“å­˜å‘½ä¸­ç‡ï¼ˆæ¨¡æ‹Ÿï¼‰
    cacheHitRate.WithLabelValues("redis").Set(getCacheHitRate("redis"))
    cacheHitRate.WithLabelValues("memcached").Set(getCacheHitRate("memcached"))
}

func getUserCount(window string) int {
    // å®é™…å®ç°ä¸­åº”è¯¥æŸ¥è¯¢æ•°æ®åº“
    return 100
}

func getCacheHitRate(cacheName string) float64 {
    // å®é™…å®ç°ä¸­åº”è¯¥æŸ¥è¯¢ç¼“å­˜ç»Ÿè®¡
    return 0.85
}
```

### 3.3 Prometheus é…ç½®ä¸æŸ¥è¯¢

```yaml
# prometheus.yml é…ç½®ç¤ºä¾‹
global:
  scrape_interval:     15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

scrape_configs:
  - job_name: 'go-app'
    static_configs:
      - targets: ['localhost:8080']
    scrape_interval: 5s
    metrics_path: /metrics

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

å¸¸ç”¨ PromQL æŸ¥è¯¢ç¤ºä¾‹ï¼š

```promql
# HTTP è¯·æ±‚ç‡
rate(http_requests_total[5m])

# æŒ‰çŠ¶æ€ç åˆ†ç»„çš„è¯·æ±‚ç‡
sum(rate(http_requests_total[5m])) by (status)

# 95åˆ†ä½å“åº”æ—¶é—´
histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))

# é”™è¯¯ç‡
sum(rate(http_requests_total{status=~"5.."}[5m])) / sum(rate(http_requests_total[5m]))

# æ´»è·ƒè¿æ¥æ•°å˜åŒ–
increase(active_connections[1h])

# ç”¨æˆ·æ³¨å†Œå¢é•¿è¶‹åŠ¿
increase(user_registrations_total[1d])
```



## HTTP æœåŠ¡çš„å¥åº·æ£€æŸ¥å®ç°

### 4.1 åŸºç¡€å¥åº·æ£€æŸ¥

```go
package main

import (
    "database/sql"
    "encoding/json"
    "fmt"
    "net/http"
    "time"
    
    _ "github.com/lib/pq"
)

// å¥åº·çŠ¶æ€æšä¸¾
type HealthStatus string

const (
    StatusHealthy   HealthStatus = "healthy"
    StatusUnhealthy HealthStatus = "unhealthy"
    StatusDegraded  HealthStatus = "degraded"
)

// å¥åº·æ£€æŸ¥å“åº”
type HealthResponse struct {
    Status    HealthStatus           `json:"status"`
    Timestamp time.Time              `json:"timestamp"`
    Version   string                 `json:"version"`
    Uptime    time.Duration          `json:"uptime"`
    Checks    map[string]CheckResult `json:"checks"`
}

type CheckResult struct {
    Status  HealthStatus `json:"status"`
    Message string       `json:"message,omitempty"`
    Latency time.Duration `json:"latency"`
}

// å¥åº·æ£€æŸ¥å™¨æ¥å£
type HealthChecker interface {
    Name() string
    Check() CheckResult
}

// æ•°æ®åº“å¥åº·æ£€æŸ¥
type DatabaseChecker struct {
    db *sql.DB
}

func NewDatabaseChecker(db *sql.DB) *DatabaseChecker {
    return &DatabaseChecker{db: db}
}

func (dc *DatabaseChecker) Name() string {
    return "database"
}

func (dc *DatabaseChecker) Check() CheckResult {
    start := time.Now()
    
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := dc.db.PingContext(ctx); err != nil {
        return CheckResult{
            Status:  StatusUnhealthy,
            Message: fmt.Sprintf("æ•°æ®åº“è¿æ¥å¤±è´¥: %v", err),
            Latency: time.Since(start),
        }
    }
    
    return CheckResult{
        Status:  StatusHealthy,
        Latency: time.Since(start),
    }
}

// Redis å¥åº·æ£€æŸ¥
type RedisChecker struct {
    client interface{ Ping() error }
}

func NewRedisChecker(client interface{ Ping() error }) *RedisChecker {
    return &RedisChecker{client: client}
}

func (rc *RedisChecker) Name() string {
    return "redis"
}

func (rc *RedisChecker) Check() CheckResult {
    start := time.Now()
    
    if err := rc.client.Ping(); err != nil {
        return CheckResult{
            Status:  StatusUnhealthy,
            Message: fmt.Sprintf("Redisè¿æ¥å¤±è´¥: %v", err),
            Latency: time.Since(start),
        }
    }
    
    return CheckResult{
        Status:  StatusHealthy,
        Latency: time.Since(start),
    }
}

// å¤–éƒ¨æœåŠ¡å¥åº·æ£€æŸ¥
type ExternalServiceChecker struct {
    name     string
    url      string
    timeout  time.Duration
    client   *http.Client
}

func NewExternalServiceChecker(name, url string, timeout time.Duration) *ExternalServiceChecker {
    return &ExternalServiceChecker{
        name:    name,
        url:     url,
        timeout: timeout,
        client:  &http.Client{Timeout: timeout},
    }
}

func (esc *ExternalServiceChecker) Name() string {
    return esc.name
}

func (esc *ExternalServiceChecker) Check() CheckResult {
    start := time.Now()
    
    resp, err := esc.client.Get(esc.url)
    if err != nil {
        return CheckResult{
            Status:  StatusUnhealthy,
            Message: fmt.Sprintf("æœåŠ¡ä¸å¯è¾¾: %v", err),
            Latency: time.Since(start),
        }
    }
    defer resp.Body.Close()
    
    if resp.StatusCode >= 200 && resp.StatusCode < 300 {
        return CheckResult{
            Status:  StatusHealthy,
            Latency: time.Since(start),
        }
    }
    
    return CheckResult{
        Status:  StatusDegraded,
        Message: fmt.Sprintf("çŠ¶æ€ç : %d", resp.StatusCode),
        Latency: time.Since(start),
    }
}

// å¥åº·æ£€æŸ¥ç®¡ç†å™¨
type HealthManager struct {
    checkers  []HealthChecker
    startTime time.Time
    version   string
}

func NewHealthManager(version string) *HealthManager {
    return &HealthManager{
        checkers:  make([]HealthChecker, 0),
        startTime: time.Now(),
        version:   version,
    }
}

func (hm *HealthManager) AddChecker(checker HealthChecker) {
    hm.checkers = append(hm.checkers, checker)
}

func (hm *HealthManager) CheckHealth() HealthResponse {
    checks := make(map[string]CheckResult)
    overallStatus := StatusHealthy
    
    for _, checker := range hm.checkers {
        result := checker.Check()
        checks[checker.Name()] = result
        
        // ç¡®å®šæ•´ä½“çŠ¶æ€
        if result.Status == StatusUnhealthy {
            overallStatus = StatusUnhealthy
        } else if result.Status == StatusDegraded && overallStatus != StatusUnhealthy {
            overallStatus = StatusDegraded
        }
    }
    
    return HealthResponse{
        Status:    overallStatus,
        Timestamp: time.Now(),
        Version:   hm.version,
        Uptime:    time.Since(hm.startTime),
        Checks:    checks,
    }
}

func (hm *HealthManager) HealthHandler(w http.ResponseWriter, r *http.Request) {
    health := hm.CheckHealth()
    
    w.Header().Set("Content-Type", "application/json")
    
    // æ ¹æ®å¥åº·çŠ¶æ€è®¾ç½® HTTP çŠ¶æ€ç 
    switch health.Status {
    case StatusHealthy, StatusDegraded:
        w.WriteHeader(http.StatusOK)
    case StatusUnhealthy:
        w.WriteHeader(http.StatusServiceUnavailable)
    }
    
    json.NewEncoder(w).Encode(health)
}

func (hm *HealthManager) ReadinessHandler(w http.ResponseWriter, r *http.Request) {
    // å°±ç»ªæ£€æŸ¥ - åªæ£€æŸ¥å…³é”®ä¾èµ–
    criticalCheckers := []string{"database"}
    
    for _, checker := range hm.checkers {
        if contains(criticalCheckers, checker.Name()) {
            result := checker.Check()
            if result.Status == StatusUnhealthy {
                w.WriteHeader(http.StatusServiceUnavailable)
                json.NewEncoder(w).Encode(map[string]string{
                    "status": "not ready",
                    "reason": result.Message,
                })
                return
            }
        }
    }
    
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]string{"status": "ready"})
}

func (hm *HealthManager) LivenessHandler(w http.ResponseWriter, r *http.Request) {
    // å­˜æ´»æ£€æŸ¥ - ç®€å•æ£€æŸ¥æœåŠ¡æ˜¯å¦å“åº”
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]string{"status": "alive"})
}

func contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}
```



## åˆ†å¸ƒå¼è¿½è¸ªå…¥é—¨ (OpenTelemetry)

### 5.1 ä»€ä¹ˆæ˜¯åˆ†å¸ƒå¼è¿½è¸ª

åˆ†å¸ƒå¼è¿½è¸ªå¸®åŠ©æˆ‘ä»¬ç†è§£è¯·æ±‚åœ¨å¾®æœåŠ¡æ¶æ„ä¸­çš„å®Œæ•´æµè½¬è·¯å¾„ï¼Œå¯¹äºGoè¯­è¨€çš„å¾®æœåŠ¡å°¤å…¶é‡è¦ã€‚

#### æ ¸å¿ƒæ¦‚å¿µ

**Traceï¼ˆè¿½è¸ªï¼‰**: ä¸€ä¸ªå®Œæ•´çš„è¯·æ±‚æµç¨‹ **Spanï¼ˆè·¨åº¦ï¼‰**: å•ä¸ªæ“ä½œå•å…ƒï¼ˆå¦‚HTTPè¯·æ±‚ã€æ•°æ®åº“æŸ¥è¯¢ï¼‰ **Contextï¼ˆä¸Šä¸‹æ–‡ï¼‰**: åœ¨goroutineå’ŒæœåŠ¡é—´ä¼ é€’è¿½è¸ªä¿¡æ¯

### 5.2 OpenTelemetry Go SDK å®‰è£…ä¸é…ç½®

bash

```bash
go get go.opentelemetry.io/otel
go get go.opentelemetry.io/otel/trace
go get go.opentelemetry.io/otel/sdk
go get go.opentelemetry.io/otel/exporters/jaeger
go get go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp
```

#### åŸºç¡€é…ç½®

```go
package main

import (
    "context"
    "log"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
)

func initTracer() func() {
    // Jaeger exporter
    exp, err := jaeger.New(jaeger.WithCollectorEndpoint(
        jaeger.WithEndpoint("http://localhost:14268/api/traces"),
    ))
    if err != nil {
        log.Fatal(err)
    }

    // Resource
    res := resource.NewWithAttributes(
        semconv.SchemaURL,
        semconv.ServiceNameKey.String("my-go-service"),
        semconv.ServiceVersionKey.String("1.0.0"),
    )

    // Tracer Provider
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exp),
        trace.WithResource(res),
    )
    
    otel.SetTracerProvider(tp)
    
    return func() {
        tp.Shutdown(context.Background())
    }
}
```

### 5.3 HTTPæœåŠ¡è¿½è¸ªå®ç°

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "time"
    
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

var tracer = otel.Tracer("example-server")

// User ç»“æ„ä½“
type User struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
}

// ç”¨æˆ·æœåŠ¡
func getUserHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // åˆ›å»ºå­span
    ctx, span := tracer.Start(ctx, "get-user")
    defer span.End()
    
    // æ·»åŠ å±æ€§
    span.SetAttributes(
        attribute.String("user.id", r.URL.Query().Get("id")),
        attribute.String("http.method", r.Method),
    )
    
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    user, err := fetchUserFromDB(ctx, r.URL.Query().Get("id"))
    if err != nil {
        span.RecordError(err)
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

// æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
func fetchUserFromDB(ctx context.Context, userID string) (*User, error) {
    ctx, span := tracer.Start(ctx, "db-query")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("db.operation", "SELECT"),
        attribute.String("db.table", "users"),
    )
    
    // æ¨¡æ‹Ÿæ•°æ®åº“å»¶è¿Ÿ
    time.Sleep(50 * time.Millisecond)
    
    return &User{ID: 1, Name: "John Doe"}, nil
}

func main() {
    cleanup := initTracer()
    defer cleanup()
    
    // ä½¿ç”¨OpenTelemetryä¸­é—´ä»¶åŒ…è£…HTTPå¤„ç†å™¨
    handler := otelhttp.NewHandler(
        http.HandlerFunc(getUserHandler),
        "get-user",
    )
    
    http.Handle("/user", handler)
    
    fmt.Println("Server running on :8080")
    http.ListenAndServe(":8080", nil)
}
```

### 5.4 æ•°æ®åº“è¿½è¸ª

```go
package main

import (
    "context"
    "database/sql"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/contrib/instrumentation/database/sql/otelSQL"
    _ "github.com/lib/pq"
)

type UserService struct {
    db *sql.DB
}

func NewUserService() *UserService {
    // ä½¿ç”¨OpenTelemetryåŒ…è£…çš„SQLé©±åŠ¨
    db, err := sql.Open("postgres", "postgresql://localhost/mydb?sslmode=disable")
    if err != nil {
        panic(err)
    }
    
    return &UserService{db: db}
}

func (s *UserService) GetUser(ctx context.Context, userID int) (*User, error) {
    tracer := otel.Tracer("user-service")
    ctx, span := tracer.Start(ctx, "UserService.GetUser")
    defer span.End()
    
    span.SetAttributes(
        attribute.Int("user.id", userID),
    )
    
    query := "SELECT id, name FROM users WHERE id = $1"
    var user User
    
    err := s.db.QueryRowContext(ctx, query, userID).Scan(&user.ID, &user.Name)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    return &user, nil
}
```



##  åº”ç”¨æ€§èƒ½ç›‘æ§åŸºç¡€

### 6.1 Goåº”ç”¨æ€§èƒ½æŒ‡æ ‡

#### æ ¸å¿ƒæŒ‡æ ‡ç±»å‹

**ä¸šåŠ¡æŒ‡æ ‡**

- QPS (æ¯ç§’æŸ¥è¯¢æ•°)
- å“åº”æ—¶é—´åˆ†ä½æ•° (P50, P95, P99)
- é”™è¯¯ç‡

**ç³»ç»ŸæŒ‡æ ‡**

- CPUä½¿ç”¨ç‡
- å†…å­˜ä½¿ç”¨é‡
- Goroutineæ•°é‡
- GCæš‚åœæ—¶é—´

**ä¾èµ–æŒ‡æ ‡**

- æ•°æ®åº“è¿æ¥æ± çŠ¶æ€
- å¤–éƒ¨APIè°ƒç”¨å»¶è¿Ÿ
- æ¶ˆæ¯é˜Ÿåˆ—ç§¯å‹

### 6.2 Prometheus + Grafana ç›‘æ§å®ç°

```go
package main

import (
    "fmt"
    "net/http"
    "time"
    
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
    // è¯·æ±‚æ€»æ•°è®¡æ•°å™¨
    httpRequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )
    
    // è¯·æ±‚æŒç»­æ—¶é—´ç›´æ–¹å›¾
    httpRequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "Duration of HTTP requests",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )
    
    // å½“å‰æ´»è·ƒè¿æ¥æ•°
    activeConnections = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "active_connections",
            Help: "Number of active connections",
        },
    )
)

// æŒ‡æ ‡ä¸­é—´ä»¶
func metricsMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // å¢åŠ æ´»è·ƒè¿æ¥
        activeConnections.Inc()
        defer activeConnections.Dec()
        
        // åŒ…è£…ResponseWriterä»¥æ•è·çŠ¶æ€ç 
        ww := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        next.ServeHTTP(ww, r)
        
        duration := time.Since(start)
        
        // è®°å½•æŒ‡æ ‡
        httpRequestsTotal.WithLabelValues(
            r.Method,
            r.URL.Path,
            fmt.Sprintf("%d", ww.statusCode),
        ).Inc()
        
        httpRequestDuration.WithLabelValues(
            r.Method,
            r.URL.Path,
        ).Observe(duration.Seconds())
    }
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

func businessHandler(w http.ResponseWriter, r *http.Request) {
    // æ¨¡æ‹Ÿä¸šåŠ¡å¤„ç†
    time.Sleep(100 * time.Millisecond)
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}

func main() {
    // ä¸šåŠ¡è·¯ç”±
    http.Handle("/api/users", metricsMiddleware(businessHandler))
    
    // PrometheusæŒ‡æ ‡ç«¯ç‚¹
    http.Handle("/metrics", promhttp.Handler())
    
    fmt.Println("Server running on :8080")
    http.ListenAndServe(":8080", nil)
}
```

### 6.3 Goè¿è¡Œæ—¶æŒ‡æ ‡ç›‘æ§

```go
package main

import (
    "runtime"
    "time"
    
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    // Goroutineæ•°é‡
    goroutinesGauge = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "go_goroutines_total",
            Help: "Number of goroutines",
        },
    )
    
    // å†…å­˜ä½¿ç”¨é‡
    memoryUsageGauge = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "go_memory_usage_bytes",
            Help: "Memory usage in bytes",
        },
        []string{"type"},
    )
    
    // GCæš‚åœæ—¶é—´
    gcPauseHistogram = promauto.NewHistogram(
        prometheus.HistogramOpts{
            Name:    "go_gc_pause_seconds",
            Help:    "GC pause duration",
            Buckets: []float64{0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1},
        },
    )
)

// æ”¶é›†Goè¿è¡Œæ—¶æŒ‡æ ‡
func collectRuntimeMetrics() {
    ticker := time.NewTicker(15 * time.Second)
    go func() {
        for {
            select {
            case <-ticker.C:
                var m runtime.MemStats
                runtime.ReadMemStats(&m)
                
                // æ›´æ–°Goroutineæ•°é‡
                goroutinesGauge.Set(float64(runtime.NumGoroutine()))
                
                // æ›´æ–°å†…å­˜æŒ‡æ ‡
                memoryUsageGauge.WithLabelValues("heap_alloc").Set(float64(m.HeapAlloc))
                memoryUsageGauge.WithLabelValues("heap_sys").Set(float64(m.HeapSys))
                memoryUsageGauge.WithLabelValues("stack_sys").Set(float64(m.StackSys))
                
                // GCæŒ‡æ ‡éœ€è¦é€šè¿‡å…¶ä»–æ–¹å¼æ”¶é›†
                // å¯ä»¥ä½¿ç”¨runtime/traceåŒ…æˆ–è‡ªå®šä¹‰GCç›‘æ§
            }
        }
    }()
}
```

### 6.4 åº”ç”¨å¥åº·æ£€æŸ¥

```go
package main

import (
    "context"
    "database/sql"
    "encoding/json"
    "net/http"
    "time"
)

type HealthStatus struct {
    Status   string            `json:"status"`
    Services map[string]string `json:"services"`
    Uptime   string           `json:"uptime"`
}

type HealthChecker struct {
    db        *sql.DB
    startTime time.Time
}

func NewHealthChecker(db *sql.DB) *HealthChecker {
    return &HealthChecker{
        db:        db,
        startTime: time.Now(),
    }
}

func (hc *HealthChecker) CheckHealth(w http.ResponseWriter, r *http.Request) {
    ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
    defer cancel()
    
    status := HealthStatus{
        Status:   "healthy",
        Services: make(map[string]string),
        Uptime:   time.Since(hc.startTime).String(),
    }
    
    // æ£€æŸ¥æ•°æ®åº“è¿æ¥
    if err := hc.db.PingContext(ctx); err != nil {
        status.Status = "unhealthy"
        status.Services["database"] = "unhealthy: " + err.Error()
    } else {
        status.Services["database"] = "healthy"
    }
    
    // æ£€æŸ¥å…¶ä»–ä¾èµ–æœåŠ¡
    // ä¾‹å¦‚ï¼šRedis, å¤–éƒ¨APIç­‰
    
    w.Header().Set("Content-Type", "application/json")
    if status.Status == "unhealthy" {
        w.WriteHeader(http.StatusServiceUnavailable)
    }
    
    json.NewEncoder(w).Encode(status)
}

// ç®€å•çš„æ´»æ€§æ£€æŸ¥
func (hc *HealthChecker) LivenessCheck(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}

// å°±ç»ªæ£€æŸ¥
func (hc *HealthChecker) ReadinessCheck(w http.ResponseWriter, r *http.Request) {
    // æ£€æŸ¥åº”ç”¨æ˜¯å¦å‡†å¤‡å¥½æ¥æ”¶æµé‡
    // ä¾‹å¦‚ï¼šæ•°æ®åº“è¿æ¥æ± æ˜¯å¦åˆå§‹åŒ–å®Œæˆ
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("Ready"))
}
```



## å¸¸è§é—®é¢˜è¯Šæ–­ä¸è°ƒè¯•æŠ€å·§

### 7.1 Goåº”ç”¨å¸¸è§æ€§èƒ½é—®é¢˜

#### å†…å­˜æ³„æ¼è¯Šæ–­

```go
package main

import (
    "fmt"
    "net/http"
    _ "net/http/pprof"
    "runtime"
)

// å†…å­˜æ³„æ¼ç¤ºä¾‹ï¼ˆé”™è¯¯ä»£ç ï¼‰
func memoryLeakExample() {
    // é”™è¯¯ï¼šgoroutineæ³„æ¼
    ch := make(chan int)
    go func() {
        // è¿™ä¸ªgoroutineæ°¸è¿œä¸ä¼šç»“æŸ
        <-ch
    }()
    // chæ°¸è¿œä¸ä¼šè¢«å†™å…¥ï¼Œå¯¼è‡´goroutineæ³„æ¼
}

// æ­£ç¡®çš„å®ç°
func correctImplementation() {
    ch := make(chan int, 1)
    go func() {
        select {
        case <-ch:
            // æ­£å¸¸å¤„ç†
        case <-time.After(5 * time.Second):
            // è¶…æ—¶å¤„ç†
            return
        }
    }()
    ch <- 1
}

// å†…å­˜åˆ†æå‡½æ•°
func analyzeMemory() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    fmt.Printf("å†…å­˜åˆ†é…: %d KB\n", m.Alloc/1024)
    fmt.Printf("ç³»ç»Ÿå†…å­˜: %d KB\n", m.Sys/1024)
    fmt.Printf("GCæ¬¡æ•°: %d\n", m.NumGC)
    fmt.Printf("Goroutineæ•°é‡: %d\n", runtime.NumGoroutine())
}

func main() {
    // å¯ç”¨pprof
    go func() {
        http.ListenAndServe(":6060", nil)
    }()
    
    // ä¸šåŠ¡ä»£ç 
}
```

#### Goroutineæ³„æ¼æ£€æµ‹

```go
package main

import (
    "context"
    "fmt"
    "runtime"
    "sync"
    "time"
)

// Goroutineæ³„æ¼æ£€æµ‹å™¨
type GoroutineLeakDetector struct {
    initialCount int
    threshold    int
    mu           sync.RWMutex
}

func NewGoroutineLeakDetector(threshold int) *GoroutineLeakDetector {
    return &GoroutineLeakDetector{
        initialCount: runtime.NumGoroutine(),
        threshold:    threshold,
    }
}

func (gld *GoroutineLeakDetector) Check() bool {
    gld.mu.RLock()
    defer gld.mu.RUnlock()
    
    current := runtime.NumGoroutine()
    increase := current - gld.initialCount
    
    if increase > gld.threshold {
        fmt.Printf("è­¦å‘Š: Goroutineæ³„æ¼æ£€æµ‹åˆ° %d ä¸ªgoroutineå¢é•¿\n", increase)
        return true
    }
    return false
}

// æ­£ç¡®çš„è¶…æ—¶å¤„ç†æ¨¡å¼
func httpClientWithTimeout(ctx context.Context, url string) error {
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel() // é‡è¦ï¼šç¡®ä¿contextè¢«å–æ¶ˆ
    
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return err
    }
    
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    return nil
}
```

### 7.2 æ•°æ®åº“æ€§èƒ½é—®é¢˜è¯Šæ–­

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

type DBMonitor struct {
    db *sql.DB
}

func NewDBMonitor(db *sql.DB) *DBMonitor {
    return &DBMonitor{db: db}
}

// æ…¢æŸ¥è¯¢ç›‘æ§
func (dm *DBMonitor) QueryWithMonitoring(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    tracer := otel.Tracer("db-monitor")
    ctx, span := tracer.Start(ctx, "db-query")
    defer span.End()
    
    start := time.Now()
    
    span.SetAttributes(
        attribute.String("db.query", query),
        attribute.Int("db.args.count", len(args)),
    )
    
    rows, err := dm.db.QueryContext(ctx, query, args...)
    
    duration := time.Since(start)
    span.SetAttributes(attribute.Float64("db.duration.seconds", duration.Seconds()))
    
    // æ…¢æŸ¥è¯¢å‘Šè­¦
    if duration > 1*time.Second {
        fmt.Printf("æ…¢æŸ¥è¯¢å‘Šè­¦: æŸ¥è¯¢è€—æ—¶ %v\næŸ¥è¯¢è¯­å¥: %s\n", duration, query)
    }
    
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    return rows, nil
}

// è¿æ¥æ± ç›‘æ§
func (dm *DBMonitor) MonitorConnectionPool() {
    stats := dm.db.Stats()
    
    fmt.Printf("æ•°æ®åº“è¿æ¥æ± çŠ¶æ€:\n")
    fmt.Printf("  æœ€å¤§æ‰“å¼€è¿æ¥æ•°: %d\n", stats.MaxOpenConnections)
    fmt.Printf("  å½“å‰æ‰“å¼€è¿æ¥æ•°: %d\n", stats.OpenConnections)
    fmt.Printf("  ä½¿ç”¨ä¸­è¿æ¥æ•°: %d\n", stats.InUse)
    fmt.Printf("  ç©ºé—²è¿æ¥æ•°: %d\n", stats.Idle)
    fmt.Printf("  ç­‰å¾…è¿æ¥æ•°: %d\n", stats.WaitCount)
    fmt.Printf("  ç­‰å¾…æ—¶é•¿: %v\n", stats.WaitDuration)
}
```

### 7.3 HTTPæœåŠ¡é—®é¢˜è¯Šæ–­

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "sync"
    "time"
)

// è¯·æ±‚è¶…æ—¶ç›‘æ§
type TimeoutMonitor struct {
    requests map[string]time.Time
    mu       sync.RWMutex
}

func NewTimeoutMonitor() *TimeoutMonitor {
    tm := &TimeoutMonitor{
        requests: make(map[string]time.Time),
    }
    
    // å®šæœŸæ¸…ç†è¶…æ—¶è¯·æ±‚
    go tm.cleanupRoutine()
    return tm
}

func (tm *TimeoutMonitor) TrackRequest(requestID string) {
    tm.mu.Lock()
    defer tm.mu.Unlock()
    tm.requests[requestID] = time.Now()
}

func (tm *TimeoutMonitor) CompleteRequest(requestID string) {
    tm.mu.Lock()
    defer tm.mu.Unlock()
    delete(tm.requests, requestID)
}

func (tm *TimeoutMonitor) cleanupRoutine() {
    ticker := time.NewTicker(30 * time.Second)
    for {
        select {
        case <-ticker.C:
            tm.mu.Lock()
            now := time.Now()
            for id, startTime := range tm.requests {
                if now.Sub(startTime) > 5*time.Minute {
                    fmt.Printf("è¶…æ—¶è¯·æ±‚æ£€æµ‹: %s å·²è¿è¡Œ %v\n", id, now.Sub(startTime))
                    delete(tm.requests, id)
                }
            }
            tm.mu.Unlock()
        }
    }
}

// ç†”æ–­å™¨å®ç°
type CircuitBreaker struct {
    maxFailures  int
    resetTimeout time.Duration
    failures     int
    lastFailTime time.Time
    state        string // "closed", "open", "half-open"
    mu           sync.RWMutex
}

func NewCircuitBreaker(maxFailures int, resetTimeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        maxFailures:  maxFailures,
        resetTimeout: resetTimeout,
        state:        "closed",
    }
}

func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥ä»opençŠ¶æ€è½¬ä¸ºhalf-open
    if cb.state == "open" && time.Since(cb.lastFailTime) > cb.resetTimeout {
        cb.state = "half-open"
        cb.failures = 0
    }
    
    // å¦‚æœæ˜¯opençŠ¶æ€ï¼Œç›´æ¥è¿”å›é”™è¯¯
    if cb.state == "open" {
        return fmt.Errorf("circuit breaker is open")
    }
    
    // æ‰§è¡Œå‡½æ•°
    err := fn()
    
    if err != nil {
        cb.failures++
        cb.lastFailTime = time.Now()
        
        if cb.failures >= cb.maxFailures {
            cb.state = "open"
        }
        return err
    }
    
    // æˆåŠŸæ‰§è¡Œï¼Œé‡ç½®çŠ¶æ€
    cb.failures = 0
    cb.state = "closed"
    return nil
}
```

### 7.4 æ—¥å¿—å’Œé”™è¯¯å¤„ç†æœ€ä½³å®è·µ

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "runtime"
    "time"
    
    "go.opentelemetry.io/otel/trace"
)

// ç»“æ„åŒ–æ—¥å¿—
type Logger struct {
    serviceName string
}

type LogEntry struct {
    Timestamp   time.Time   `json:"timestamp"`
    Level       string      `json:"level"`
    Message     string      `json:"message"`
    Service     string      `json:"service"`
    TraceID     string      `json:"trace_id,omitempty"`
    SpanID      string      `json:"span_id,omitempty"`
    Error       string      `json:"error,omitempty"`
    Fields      interface{} `json:"fields,omitempty"`
    Caller      string      `json:"caller,omitempty"`
}

func NewLogger(serviceName string) *Logger {
    return &Logger{serviceName: serviceName}
}

func (l *Logger) logWithContext(ctx context.Context, level, message string, err error, fields interface{}) {
    entry := LogEntry{
        Timestamp: time.Now(),
        Level:     level,
        Message:   message,
        Service:   l.serviceName,
        Fields:    fields,
    }
    
    // æ·»åŠ è°ƒç”¨è€…ä¿¡æ¯
    if _, file, line, ok := runtime.Caller(3); ok {
        entry.Caller = fmt.Sprintf("%s:%d", file, line)
    }
    
    // æ·»åŠ è¿½è¸ªä¿¡æ¯
    if span := trace.SpanFromContext(ctx); span.SpanContext().IsValid() {
        entry.TraceID = span.SpanContext().TraceID().String()
        entry.SpanID = span.SpanContext().SpanID().String()
    }
    
    if err != nil {
        entry.Error = err.Error()
    }
    
    jsonBytes, _ := json.Marshal(entry)
    log.Println(string(jsonBytes))
}

func (l *Logger) Info(ctx context.Context, message string, fields interface{}) {
    l.logWithContext(ctx, "INFO", message, nil, fields)
}

func (l *Logger) Error(ctx context.Context, message string, err error, fields interface{}) {
    l.logWithContext(ctx, "ERROR", message, err, fields)
}

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
func errorHandlingMiddleware(logger *Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            defer func() {
                if err := recover(); err != nil {
                    logger.Error(r.Context(), "panic recovered", fmt.Errorf("%v", err), map[string]interface{}{
                        "url":    r.URL.String(),
                        "method": r.Method,
                    })
                    
                    http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                }
            }()
            
            next.ServeHTTP(w, r)
        })
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func businessLogic(ctx context.Context, logger *Logger) error {
    logger.Info(ctx, "å¼€å§‹å¤„ç†ä¸šåŠ¡é€»è¾‘", map[string]interface{}{
        "user_id": 123,
        "action":  "create_order",
    })
    
    // æ¨¡æ‹Ÿå¯èƒ½å‡ºé”™çš„æ“ä½œ
    if time.Now().Unix()%2 == 0 {
        err := fmt.Errorf("æ¨¡æ‹Ÿä¸šåŠ¡é”™è¯¯")
        logger.Error(ctx, "ä¸šåŠ¡å¤„ç†å¤±è´¥", err, map[string]interface{}{
            "user_id": 123,
        })
        return err
    }
    
    logger.Info(ctx, "ä¸šåŠ¡é€»è¾‘å¤„ç†å®Œæˆ", nil)
    return nil
}
```

### 7.5 è°ƒè¯•å·¥å…·ä½¿ç”¨

#### pprof æ€§èƒ½åˆ†æ

```bash
# å¯åŠ¨pprof HTTPæœåŠ¡å™¨
import _ "net/http/pprof"

# CPUæ€§èƒ½åˆ†æ
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# å†…å­˜åˆ†æ
go tool pprof http://localhost:6060/debug/pprof/heap

# Goroutineåˆ†æ
go tool pprof http://localhost:6060/debug/pprof/goroutine

# é˜»å¡åˆ†æ
go tool pprof http://localhost:6060/debug/pprof/block
```

#### Trace åˆ†æ

```go
package main

import (
    "os"
    "runtime/trace"
)

func enableTracing() func() {
    f, err := os.Create("trace.out")
    if err != nil {
        panic(err)
    }
    
    if err := trace.Start(f); err != nil {
        panic(err)
    }
    
    return func() {
        trace.Stop()
        f.Close()
    }
}

// ä½¿ç”¨: go tool trace trace.out
```

### 7.6 ç›‘æ§å‘Šè­¦é…ç½®

```yaml
# Prometheuså‘Šè­¦è§„åˆ™ç¤ºä¾‹ (alerts.yml)
groups:
- name: golang-app
  rules:
  - alert: HighErrorRate
    expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "é«˜é”™è¯¯ç‡å‘Šè­¦"
      description: "é”™è¯¯ç‡è¶…è¿‡10%ï¼ŒæŒç»­5åˆ†é’Ÿ"
      
  - alert: HighLatency
    expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "é«˜å»¶è¿Ÿå‘Šè­¦"
      description: "95åˆ†ä½å»¶è¿Ÿè¶…è¿‡1ç§’"
      
  - alert: TooManyGoroutines
    expr: go_goroutines_total > 1000
    for: 10m
    labels:
      severity: warning
    annotations:
      summary: "Goroutineæ•°é‡è¿‡å¤š"
      description: "Goroutineæ•°é‡è¶…è¿‡1000ä¸ªï¼Œå¯èƒ½å­˜åœ¨æ³„æ¼"
```

## æ€»ç»“

Goè¯­è¨€çš„åˆ†å¸ƒå¼è¿½è¸ªå’Œæ€§èƒ½ç›‘æ§éœ€è¦ç»¼åˆè¿ç”¨å¤šç§æŠ€æœ¯å’Œå·¥å…·ï¼š

### å…³é”®è¦ç‚¹

**åˆ†å¸ƒå¼è¿½è¸ª**

- ä½¿ç”¨OpenTelemetry Go SDKå®ç°æ ‡å‡†åŒ–çš„è¿½è¸ª
- åœ¨å…³é”®ä¸šåŠ¡èŠ‚ç‚¹åˆ›å»ºSpanæ¥è¿½è¸ªè¯·æ±‚æµè½¬
- é€šè¿‡Contextåœ¨goroutineé—´ä¼ é€’è¿½è¸ªä¿¡æ¯
- é›†æˆJaegeræˆ–Zipkinç­‰åç«¯å­˜å‚¨å’Œå¯è§†åŒ–å·¥å…·

**æ€§èƒ½ç›‘æ§**

- ä½¿ç”¨Prometheusæ”¶é›†æŒ‡æ ‡ï¼ŒGrafanaå¯è§†åŒ–
- ç›‘æ§ä¸šåŠ¡æŒ‡æ ‡ï¼ˆQPSã€å»¶è¿Ÿã€é”™è¯¯ç‡ï¼‰å’Œç³»ç»ŸæŒ‡æ ‡ï¼ˆCPUã€å†…å­˜ã€Goroutineï¼‰
- å®ç°å¥åº·æ£€æŸ¥ç«¯ç‚¹æ”¯æŒå®¹å™¨ç¼–æ’
- å»ºç«‹å‘Šè­¦æœºåˆ¶åŠæ—¶å‘ç°é—®é¢˜

**é—®é¢˜è¯Šæ–­**

- ä½¿ç”¨pprofåˆ†æCPUå’Œå†…å­˜ä½¿ç”¨æƒ…å†µ
- é€šè¿‡traceå·¥å…·åˆ†æç¨‹åºæ‰§è¡Œæµç¨‹
- å®ç°ç»“æ„åŒ–æ—¥å¿—è®°å½•å…³é”®ä¿¡æ¯
- ä½¿ç”¨ç†”æ–­å™¨æ¨¡å¼é˜²æ­¢çº§è”æ•…éšœ

**æœ€ä½³å®è·µ**

- åœ¨ä»£ç ä¸­åŸ‹ç‚¹æ—¶ä¿æŒæ€§èƒ½å½±å“æœ€å°
- ä½¿ç”¨é‡‡æ ·ç‡æ§åˆ¶è¿½è¸ªæ•°æ®é‡
- å»ºç«‹æ ‡å‡†åŒ–çš„æ—¥å¿—æ ¼å¼
- å®šæœŸè¿›è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
- å®æ–½æ¸è¿›å¼éƒ¨ç½²å’Œç›‘æ§
