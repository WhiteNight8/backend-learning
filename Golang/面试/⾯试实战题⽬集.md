

# 基础语法与特性

# defer 语句执行顺序

```go
package main

import "fmt"

func deferExample() {
    fmt.Println("函数开始执行")
    
    defer fmt.Println("第一个defer")
    defer fmt.Println("第二个defer")
    defer fmt.Println("第三个defer")
    
    fmt.Println("函数主体执行")
}

// defer 参数求值时机
func deferWithVariable() {
    i := 0
    defer fmt.Println("defer中的i:", i) // i=0，在defer声明时确定
    i++
    fmt.Println("函数中的i:", i) // i=1
}

// defer 在panic时的执行
func deferWithPanic() {
    defer fmt.Println("defer 1")
    defer fmt.Println("defer 2")
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("捕获panic:", r)
        }
    }()
    panic("发生panic")
}

func main() {
    fmt.Println("=== defer执行顺序 ===")
    deferExample()
    
    fmt.Println("\n=== defer参数求值 ===")
    deferWithVariable()
    
    fmt.Println("\n=== defer与panic ===")
    deferWithPanic()
}

// 输出结果：
// === defer执行顺序 ===
// 函数开始执行
// 函数主体执行
// 第三个defer
// 第二个defer
// 第一个defer
//
// === defer参数求值 ===
// 函数中的i: 1
// defer中的i: 0
//
// === defer与panic ===
// 捕获panic: 发生panic
// defer 2
// defer 1
```



## 闭包在 Go 中的应用及注意事项

```go
package main

import "fmt"

// 基本闭包示例
func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

// 闭包捕获变量的注意事项
func closureWithLoop() {
    fmt.Println("=== 闭包与循环变量 ===")
    
    // 错误示例：所有闭包都引用同一个变量
    var funcs []func()
    for i := 0; i < 3; i++ {
        funcs = append(funcs, func() {
            fmt.Println("错误示例，i =", i) // 都是3
        })
    }
    
    for _, f := range funcs {
        f()
    }
    
    // 正确示例1：传递参数
    var funcs2 []func()
    for i := 0; i < 3; i++ {
        funcs2 = append(funcs2, func(val int) func() {
            return func() {
                fmt.Println("正确示例1，val =", val)
            }
        }(i))
    }
    
    for _, f := range funcs2 {
        f()
    }
    
    // 正确示例2：重新声明变量
    var funcs3 []func()
    for i := 0; i < 3; i++ {
        i := i // 重新声明，创建新的变量
        funcs3 = append(funcs3, func() {
            fmt.Println("正确示例2，i =", i)
        })
    }
    
    for _, f := range funcs3 {
        f()
    }
}

// 闭包实现工厂模式
func operatorFactory(op string) func(int, int) int {
    switch op {
    case "+":
        return func(a, b int) int { return a + b }
    case "-":
        return func(a, b int) int { return a - b }
    case "*":
        return func(a, b int) int { return a * b }
    case "/":
        return func(a, b int) int { 
            if b == 0 {
                panic("除数不能为0")
            }
            return a / b 
        }
    default:
        return func(a, b int) int { return 0 }
    }
}

// 闭包与defer结合
func closureWithDefer() {
    x := 1
    defer func() {
        fmt.Println("defer中的x:", x) // x=2，闭包捕获变量引用
    }()
    x = 2
    fmt.Println("函数中的x:", x)
}

func main() {
    // 基本闭包使用
    fmt.Println("=== 基本闭包 ===")
    c1 := counter()
    c2 := counter()
    fmt.Println(c1()) // 1
    fmt.Println(c1()) // 2
    fmt.Println(c2()) // 1，独立的闭包
    
    // 闭包与循环
    closureWithLoop()
    
    // 工厂模式
    fmt.Println("\n=== 闭包工厂模式 ===")
    add := operatorFactory("+")
    mul := operatorFactory("*")
    fmt.Println("5 + 3 =", add(5, 3))
    fmt.Println("5 * 3 =", mul(5, 3))
    
    // 闭包与defer
    fmt.Println("\n=== 闭包与defer ===")
    closureWithDefer()
}
```



## make 与 new 的区别及使用场景

```go
package main

import "fmt"

func demonstrateMakeVsNew() {
    fmt.Println("=== make vs new 区别 ===")
    
    // new: 分配内存并返回指针，值为零值
    fmt.Println("--- new 的使用 ---")
    var p1 *[]int = new([]int)
    fmt.Printf("new([]int): %v, 类型: %T, 是否为nil: %v\n", p1, p1, *p1 == nil)
    
    var p2 *map[string]int = new(map[string]int)
    fmt.Printf("new(map[string]int): %v, 类型: %T, 是否为nil: %v\n", p2, p2, *p2 == nil)
    
    var p3 *chan int = new(chan int)
    fmt.Printf("new(chan int): %v, 类型: %T, 是否为nil: %v\n", p3, p3, *p3 == nil)
    
    // make: 初始化slice、map、chan，返回类型本身
    fmt.Println("\n--- make 的使用 ---")
    s1 := make([]int, 5)
    fmt.Printf("make([]int, 5): %v, 类型: %T, 长度: %d, 容量: %d\n", s1, s1, len(s1), cap(s1))
    
    s2 := make([]int, 3, 10)
    fmt.Printf("make([]int, 3, 10): %v, 类型: %T, 长度: %d, 容量: %d\n", s2, s2, len(s2), cap(s2))
    
    m1 := make(map[string]int)
    fmt.Printf("make(map[string]int): %v, 类型: %T, 是否为nil: %v\n", m1, m1, m1 == nil)
    
    c1 := make(chan int)
    fmt.Printf("make(chan int): %v, 类型: %T, 是否为nil: %v\n", c1, c1, c1 == nil)
    
    c2 := make(chan int, 5)
    fmt.Printf("make(chan int, 5): %v, 类型: %T, 容量: %d\n", c2, c2, cap(c2))
}

func demonstrateUsageScenarios() {
    fmt.Println("\n=== 使用场景示例 ===")
    
    // 场景1: 需要指向零值的指针
    fmt.Println("--- 指向零值的指针 ---")
    type Person struct {
        Name string
        Age  int
    }
    
    p := new(Person) // 等价于 p := &Person{}
    fmt.Printf("new(Person): %+v\n", *p)
    
    // 场景2: 初始化引用类型
    fmt.Println("\n--- 初始化引用类型 ---")
    
    // slice使用make
    numbers := make([]int, 0, 10) // 长度0，容量10
    numbers = append(numbers, 1, 2, 3)
    fmt.Printf("slice: %v, len=%d, cap=%d\n", numbers, len(numbers), cap(numbers))
    
    // map使用make
    scores := make(map[string]int)
    scores["Alice"] = 95
    scores["Bob"] = 87
    fmt.Printf("map: %v\n", scores)
    
    // channel使用make
    ch := make(chan string, 2)
    ch <- "hello"
    ch <- "world"
    fmt.Printf("channel length: %d, capacity: %d\n", len(ch), cap(ch))
    
    // 场景3: 错误的使用方式
    fmt.Println("\n--- 常见错误 ---")
    
    // 错误: 使用new创建的map/slice/chan需要重新初始化
    var wrongMap *map[string]int = new(map[string]int)
    // (*wrongMap)["key"] = 1 // 这会panic，因为map是nil
    
    // 正确: 需要先make
    *wrongMap = make(map[string]int)
    (*wrongMap)["key"] = 1
    fmt.Printf("修正后的map: %v\n", *wrongMap)
}

func memoryComparison() {
    fmt.Println("\n=== 内存分配对比 ===")
    
    // new分配内存
    fmt.Println("--- new 分配 ---")
    var newSlice *[]int = new([]int)
    fmt.Printf("new slice 地址: %p, 值: %v\n", newSlice, *newSlice)
    
    // make初始化
    fmt.Println("--- make 初始化 ---")
    makeSlice := make([]int, 5)
    fmt.Printf("make slice 地址: %p, 值: %v\n", &makeSlice, makeSlice)
    
    // 等价写法对比
    fmt.Println("\n--- 等价写法 ---")
    // new(T) 等价于
    var t1 int
    p1 := &t1
    p2 := new(int)
    fmt.Printf("&variable: %p, new(int): %p\n", p1, p2)
    
    // make只能用于slice、map、chan
    // 以下代码会编译错误:
    // var wrongInt = make(int) // cannot make int
}

func main() {
    demonstrateMakeVsNew()
    demonstrateUsageScenarios()
    memoryComparison()
}
```



## Go 语言中的值传递与引用传递

```go
package main

import "fmt"

// Go语言只有值传递，但不同类型表现不同

// 基本类型的值传递
func modifyInt(x int) {
    x = 100
    fmt.Printf("函数内 x = %d, 地址: %p\n", x, &x)
}

func modifyIntByPointer(x *int) {
    *x = 100
    fmt.Printf("函数内 *x = %d, 指针地址: %p, 指向地址: %p\n", *x, &x, x)
}

// 结构体的值传递
type Person struct {
    Name string
    Age  int
}

func modifyPerson(p Person) {
    p.Name = "Modified"
    p.Age = 999
    fmt.Printf("函数内 person: %+v, 地址: %p\n", p, &p)
}

func modifyPersonByPointer(p *Person) {
    p.Name = "Modified"
    p.Age = 999
    fmt.Printf("函数内 person: %+v, 指针地址: %p, 指向地址: %p\n", *p, &p, p)
}

// 切片的特殊情况
func modifySlice(s []int) {
    fmt.Printf("函数内slice地址: %p, 底层数组地址: %p\n", &s, &s[0])
    s[0] = 999    // 修改底层数组，原slice也会改变
    s = append(s, 100) // 重新分配，不影响原slice
    fmt.Printf("append后slice: %v, 地址: %p\n", s, &s)
}

func modifySliceByPointer(s *[]int) {
    (*s)[0] = 888
    *s = append(*s, 200)
    fmt.Printf("指针方式修改后: %v, 地址: %p\n", *s, s)
}

// map的引用行为
func modifyMap(m map[string]int) {
    m["new"] = 100
    fmt.Printf("函数内map: %v, 地址: %p\n", m, &m)
}

// channel的引用行为
func modifyChannel(ch chan int) {
    ch <- 100
    fmt.Printf("函数内channel地址: %p\n", &ch)
}

// 接口的值传递
type Speaker interface {
    Speak() string
}

type Dog struct {
    Name string
}

func (d Dog) Speak() string {
    return d.Name + " says woof!"
}

func modifyInterface(s Speaker) {
    if dog, ok := s.(Dog); ok {
        dog.Name = "Modified Dog"
        fmt.Printf("函数内修改后: %s\n", dog.Speak())
    }
}

func modifyInterfaceByPointer(s Speaker) {
    if dog, ok := s.(*Dog); ok {
        dog.Name = "Modified Dog"
        fmt.Printf("函数内修改后: %s\n", dog.Speak())
    }
}

func main() {
    fmt.Println("=== Go语言参数传递机制 ===")
    
    // 基本类型
    fmt.Println("\n--- 基本类型 ---")
    x := 10
    fmt.Printf("调用前 x = %d, 地址: %p\n", x, &x)
    modifyInt(x)
    fmt.Printf("调用后 x = %d, 地址: %p\n", x, &x)
    
    fmt.Println("\n--- 基本类型指针 ---")
    y := 20
    fmt.Printf("调用前 y = %d, 地址: %p\n", y, &y)
    modifyIntByPointer(&y)
    fmt.Printf("调用后 y = %d, 地址: %p\n", y, &y)
    
    // 结构体
    fmt.Println("\n--- 结构体值传递 ---")
    p1 := Person{Name: "Alice", Age: 25}
    fmt.Printf("调用前 person: %+v, 地址: %p\n", p1, &p1)
    modifyPerson(p1)
    fmt.Printf("调用后 person: %+v, 地址: %p\n", p1, &p1)
    
    fmt.Println("\n--- 结构体指针传递 ---")
    p2 := Person{Name: "Bob", Age: 30}
    fmt.Printf("调用前 person: %+v, 地址: %p\n", p2, &p2)
    modifyPersonByPointer(&p2)
    fmt.Printf("调用后 person: %+v, 地址: %p\n", p2, &p2)
    
    // 切片
    fmt.Println("\n--- 切片传递 ---")
    s1 := []int{1, 2, 3}
    fmt.Printf("调用前slice: %v, 地址: %p, 底层数组地址: %p\n", s1, &s1, &s1[0])
    modifySlice(s1)
    fmt.Printf("调用后slice: %v, 地址: %p, 底层数组地址: %p\n", s1, &s1, &s1[0])
    
    fmt.Println("\n--- 切片指针传递 ---")
    s2 := []int{4, 5, 6}
    fmt.Printf("调用前slice: %v, 地址: %p\n", s2, &s2)
    modifySliceByPointer(&s2)
    fmt.Printf("调用后slice: %v, 地址: %p\n", s2, &s2)
    
    // map
    fmt.Println("\n--- map传递 ---")
    m1 := map[string]int{"a": 1, "b": 2}
    fmt.Printf("调用前map: %v, 地址: %p\n", m1, &m1)
    modifyMap(m1)
    fmt.Printf("调用后map: %v, 地址: %p\n", m1, &m1)
    
    // channel
    fmt.Println("\n--- channel传递 ---")
    ch := make(chan int, 2)
    fmt.Printf("调用前channel地址: %p\n", &ch)
    go modifyChannel(ch)
    value := <-ch
    fmt.Printf("接收到的值: %d, channel地址: %p\n", value, &ch)
    
    // 接口
    fmt.Println("\n--- 接口值传递 ---")
    dog1 := Dog{Name: "Buddy"}
    fmt.Printf("调用前: %s\n", dog1.Speak())
    modifyInterface(dog1)
    fmt.Printf("调用后: %s\n", dog1.Speak())
    
    fmt.Println("\n--- 接口指针传递 ---")
    dog2 := &Dog{Name: "Max"}
    fmt.Printf("调用前: %s\n", dog2.Speak())
    modifyInterfaceByPointer(dog2)
    fmt.Printf("调用后: %s\n", dog2.Speak())
    
    // 总结
    fmt.Println("\n=== 总结 ===")
    fmt.Println("1. Go只有值传递，但表现因类型而异")
    fmt.Println("2. 基本类型、结构体: 完全复制，修改不影响原值")
    fmt.Println("3. 指针: 复制指针值，但指向同一内存")
    fmt.Println("4. slice、map、channel: 复制描述符，共享底层数据")
    fmt.Println("5. 接口: 复制接口值，具体行为看底层类型")
}
```



## nil 在 Go 中的意义与注意事项

```go
package main

import (
    "fmt"
    "reflect"
)

// nil的不同类型表现
func demonstrateNilTypes() {
    fmt.Println("=== nil 的不同类型 ===")
    
    // 指针
    var p *int
    fmt.Printf("指针 *int: %v, 是否为nil: %v\n", p, p == nil)
    
    // 切片
    var s []int
    fmt.Printf("切片 []int: %v, 是否为nil: %v, 长度: %d, 容量: %d\n", s, s == nil, len(s), cap(s))
    
    // map
    var m map[string]int
    fmt.Printf("map map[string]int: %v, 是否为nil: %v\n", m, m == nil)
    
    // channel
    var ch chan int
    fmt.Printf("channel chan int: %v, 是否为nil: %v\n", ch, ch == nil)
    
    // 函数
    var f func()
    fmt.Printf("函数 func(): %v, 是否为nil: %v\n", f, f == nil)
    
    // 接口
    var i interface{}
    fmt.Printf("接口 interface{}: %v, 是否为nil: %v\n", i, i == nil)
}

// nil的陷阱与注意事项
func demonstrateNilTraps() {
    fmt.Println("\n=== nil 陷阱与注意事项 ===")
    
    // 陷阱1: nil切片vs空切片
    fmt.Println("--- nil切片 vs 空切片 ---")
    var nilSlice []int
    emptySlice := []int{}
    emptySlice2 := make([]int, 0)
    
    fmt.Printf("nil切片: %v, 是否为nil: %v\n", nilSlice, nilSlice == nil)
    fmt.Printf("空切片1: %v, 是否为nil: %v\n", emptySlice, emptySlice == nil)
    fmt.Printf("空切片2: %v, 是否为nil: %v\n", emptySlice2, emptySlice2 == nil)
    
    // nil切片可以append
    nilSlice = append(nilSlice, 1, 2, 3)
    fmt.Printf("append后的nil切片: %v\n", nilSlice)
    
    // 陷阱2: nil map不能写入
    fmt.Println("\n--- nil map 陷阱 ---")
    var nilMap map[string]int
    fmt.Printf("nil map: %v, 是否为nil: %v\n", nilMap, nilMap == nil)
    
    // 读取nil map返回零值
    value := nilMap["key"]
    fmt.Printf("从nil map读取: %v\n", value)
    
    // 写入nil map会panic
    // nilMap["key"] = 1 // 这会panic: assignment to entry in nil map
    
    // 正确做法: 初始化map
    nilMap = make(map[string]int)
    nilMap["key"] = 1
    fmt.Printf("初始化后的map: %v\n", nilMap)
    
    // 陷阱3: nil channel操作
    fmt.Println("\n--- nil channel 陷阱 ---")
    var nilCh chan int
    fmt.Printf("nil channel: %v, 是否为nil: %v\n", nilCh, nilCh == nil)
    
    // 对nil channel的操作会阻塞
    go func() {
        fmt.Println("尝试从nil channel读取会永久阻塞")
        // <-nilCh // 这会永久阻塞
    }()
    
    go func() {
        fmt.Println("尝试向nil channel写入会永久阻塞")  
        // nilCh <- 1 // 这会永久阻塞
    }()
}

// 接口与nil的复杂情况
type MyError struct {
    msg string
}

func (e *MyError) Error() string {
    return e.msg
}

func returnNilError() error {
    var err *MyError = nil
    return err // 返回的不是nil接口!
}

func returnNilInterface() error {
    return nil // 返回nil接口
}

func demonstrateInterfaceNil() {
    fmt.Println("\n=== 接口与nil ===")
    
    // 接口的nil判断陷阱
    err1 := returnNilError()
    err2 := returnNilInterface()
    
    fmt.Printf("err1 == nil: %v\n", err1 == nil) // false!
    fmt.Printf("err2 == nil: %v\n", err2 == nil) // true
    
    // 查看接口内部结构
    fmt.Printf("err1 类型: %T, 值: %v\n", err1, err1)
    fmt.Printf("err2 类型: %T, 值: %v\n", err2, err2)
    
    // 正确检查接口是否为nil
    if err1 != nil {
        fmt.Println("err1 不为nil，但其值是nil指针")
        // 安全的调用方式
        if err1.(*MyError) != nil {
            fmt.Println("MyError指针不为nil")
        } else {
            fmt.Println("MyError指针为nil")
        }
    }
    
    // 使用反射检查
    fmt.Printf("err1反射是否为nil: %v\n", reflect.ValueOf(err1).IsNil())
}

// nil的安全使用模式
func demonstrateSafeNilUsage() {
    fmt.Println("\n=== nil 安全使用模式 ===")
    
    // 1. 安全的切片操作
    var s []int
    fmt.Printf("nil切片长度: %d, 容量: %d\n", len(s), cap(s))
    
    // 安全的遍历
    for i, v := range s {
        fmt.Printf("索引: %d, 值: %d\n", i, v) // 不会执行
    }
    
    // 2. 安全的map操作
    var m map[string]int
    if m == nil {
        m = make(map[string]int)
    }
    m["key"] = 1
    
    // 3. 安全的指针操作
    var p *int
    if p != nil {
        fmt.Printf("指针值: %d\n", *p)
    } else {
        fmt.Println("指针为nil，不能解引用")
    }
    
    // 4. 安全的函数调用
    var f func()
    if f != nil {
        f()
    } else {
        fmt.Println("函数为nil，不能调用")
    }
    
    // 5. 安全的channel操作
    var ch chan int
    select {
    case <-ch:
        fmt.Println("从channel接收数据")
    default:
        fmt.Println("channel为nil或无数据")
    }
}

func main() {
    demonstrateNilTypes()
    demonstrateNilTraps()
    demonstrateInterfaceNil()
    demonstrateSafeNilUsage()
    
    fmt.Println("\n=== nil 总结 ===")
    fmt.Println("1. nil是多种类型的零值：指针、切片、map、channel、函数、接口")
    fmt.Println("2. nil切片可以安全使用，但nil map写入会panic")
    fmt.Println("3. nil channel操作会永久阻塞")
    fmt.Println("4. 接口的nil判断需要特别注意，值为nil的指针接口不等于nil")
    fmt.Println("5. 使用前检查nil是良好的编程习惯")
}
```



##  Go 语言中的 string 与 []byte 转换

```go
package main

import (
    "fmt"
    "reflect"
    "unsafe"
)

// string与[]byte的基本转换
func basicConversion() {
    fmt.Println("=== string 与 []byte 基本转换 ===")
    
    // string to []byte
    s := "Hello, 世界"
    b := []byte(s)
    fmt.Printf("原字符串: %s\n", s)
    fmt.Printf("转换为[]byte: %v\n", b)
    fmt.Printf("[]byte长度: %d\n", len(b))
    
    // []byte to string
    b2 := []byte{72, 101, 108, 108, 111, 44, 32, 228, 184, 150, 231, 149, 140}
    s2 := string(b2)
    fmt.Printf("[]byte: %v\n", b2)
    fmt.Printf("转换为字符串: %s\n", s2)
    
    // 修改[]byte不影响原string
    b[0] = 'h'
    fmt.Printf("修改[]byte后，原字符串: %s\n", s)
    fmt.Printf("修改后的[]byte: %v\n", b)
}

// 性能对比：标准转换 vs 零拷贝转换
func performanceComparison() {
    fmt.Println("\n=== 性能对比 ===")
    
    s := "这是一个用于测试性能的字符串"
    
    // 标准转换（有内存分配）
    fmt.Println("--- 标准转换 ---")
    b1 := []byte(s)
    s1 := string(b1)
    fmt.Printf("标准转换结果: %s\n", s1)
    
    // 零拷贝转换（不安全，仅演示）
    fmt.Println("--- 零拷贝转换（不安全）---")
    b2 := stringToBytes(s)
    s2 := bytesToString(b2)
    fmt.Printf("零拷贝转换结果: %s\n", s2)
    
    // 验证内存地址
    fmt.Printf("原字符串地址: %p\n", &s)
    fmt.Printf("标准转换[]byte地址: %p\n", &b1[0])
    fmt.Printf("零拷贝[]byte地址: %p\n", &b2[0])
}

// 不安全的零拷贝转换（仅用于只读场景）
func stringToBytes(s string) []byte {
    return *(*[]byte)(unsafe.Pointer(
        &struct {
            string
            Cap int
        }{s, len(s)},
    ))
}

func bytesToString(b []byte) string {
    return *(*string)(unsafe.Pointer(&b))
}

// 字符串内部结构分析
func stringInternals() {
    fmt.Println("\n=== 字符串内部结构 ===")
    
    s := "Hello"
    b := []byte(s)
    
    // 使用反射查看内部结构
    sHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))
    bHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))
    
    fmt.Printf("string内部结构:\n")
    fmt.Printf("  Data: %v\n", sHeader.Data)
    fmt.Printf("  Len: %v\n", sHeader.Len)
    
    fmt.Printf("[]byte内部结构:\n")
    fmt.Printf("  Data: %v\n", bHeader.Data)
    fmt.Printf("  Len: %v\n", bHeader.Len)
    fmt.Printf("  Cap: %v\n", bHeader.Cap)
    
    // 验证数据地址不同（标准转换会复制）
    fmt.Printf("地址是否相同: %v\n", sHeader.Data == bHeader.Data)
}

// UTF-8编码处理
func utf8Handling() {
    fmt.Println("\n=== UTF-8 编码处理 ===")
    
    s := "Go语言"
    b := []byte(s)
    
    fmt.Printf("字符串: %s\n", s)
    fmt.Printf("字符串长度(字节): %d\n", len(s))
    fmt.Printf("字符串长度(字符): %d\n", len([]rune(s)))
    fmt.Printf("[]byte: %v\n", b)
    
    // 逐字节打印
    fmt.Print("逐字节: ")
    for i, v := range b {
        fmt.Printf("[%d]=%d ", i, v)
    }
    fmt.Println()
    
    // 逐字符打印
    fmt.Print("逐字符: ")
    for i, r := range s {
        fmt.Printf("[%d]=%c(U+%04X) ", i, r, r)
    }
    fmt.Println()
    
    // rune切片转换
    runes := []rune(s)
    fmt.Printf("rune切片: %v\n", runes)
    fmt.Printf("从rune切片恢复: %s\n", string(runes))
}

// 实际应用场景
func practicalUseCases() {
    fmt.Println("\n=== 实际应用场景 ===")
    
    // 场景1: 字符串拼接优化
    fmt.Println("--- 字符串拼接 ---")
    parts := []string{"Hello", " ", "World", "!"}
    
    // 方法1: 直接拼接
    result1 := ""
    for _, part := range parts {
        result1 += part
    }
    fmt.Printf("直接拼接: %s\n", result1)
    
    // 方法2: 使用[]byte缓冲
    var buf []byte
    for _, part := range parts {
        buf = append(buf, []byte(part)...)
    }
    result2 := string(buf)
    fmt.Printf("[]byte缓冲: %s\n", result2)
    
    // 场景2: 字符串修改
    fmt.Println("\n--- 字符串修改 ---")
    original := "Hello World"
    fmt.Printf("原字符串: %s\n", original)
    
    // string不可变，需要转换为[]byte修改
    modifiable := []byte(original)
    modifiable[6] = 'w' // World -> world
    modified := string(modifiable)
    fmt.Printf("修改后: %s\n", modified)
    
    // 场景3: 二进制数据处理
    fmt.Println("\n--- 二进制数据处理 ---")
    data := []byte{0x48, 0x65, 0x6c, 0x6c, 0x6f}
    text := string(data)
    fmt.Printf("二进制数据: %v\n", data)
    fmt.Printf("转换为文本: %s\n", text)
    
    // 场景4: 网络协议处理
    fmt.Println("\n--- 网络协议模拟 ---")
    packet := "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nHello"
    lines := splitLines([]byte(packet))
    for i, line := range lines {
        fmt.Printf("行 %d: %s\n", i, string(line))
    }
}

// 辅助函数：按行分割
func splitLines(data []byte) [][]byte {
    var lines [][]byte
    start := 0
    
    for i := 0; i < len(data)-1; i++ {
        if data[i] == '\r' && data[i+1] == '\n' {
            lines = append(lines, data[start:i])
            start = i + 2
            i++ // 跳过\n
        }
    }
    
    if start < len(data) {
        lines = append(lines, data[start:])
    }
    
    return lines
}

// 最佳实践建议
func bestPractices() {
    fmt.Println("\n=== 最佳实践 ===")
    
    fmt.Println("1. 转换性能考虑:")
    fmt.Println("   - string ↔ []byte 转换会分配新内存")
    fmt.Println("   - 频繁转换可能影响性能")
    fmt.Println("   - 考虑直接使用[]byte处理，最后转string")
    
    fmt.Println("\n2. 安全性考虑:")
    fmt.Println("   - 避免使用unsafe包进行零拷贝转换")
    fmt.Println("   - string是不可变的，[]byte是可变的")
    fmt.Println("   - 修改从string转换来的[]byte不会影响原string")
    
    fmt.Println("\n3. UTF-8处理:")
    fmt.Println("   - len(string)返回字节数，不是字符数")
    fmt.Println("   - 使用[]rune处理Unicode字符")
    fmt.Println("   - range遍历string按字符，按[]byte遍历按字节")
    
    fmt.Println("\n4. 内存优化:")
    fmt.Println("   - 大量字符串处理时考虑使用strings.Builder")
    fmt.Println("   - 预分配[]byte容量以减少内存重分配")
    fmt.Println("   - 及时释放不需要的大字符串引用")
}

func main() {
    basicConversion()
    performanceComparison()
    stringInternals()
    utf8Handling()
    practicalUseCases()
    bestPractices()
}
```



##  Go 语言中的类型系统与类型断言

```go
package main

import (
    "fmt"
    "reflect"
)

// Go的类型系统基础
func typeSystemBasics() {
    fmt.Println("=== Go类型系统基础 ===")
    
    // 静态类型
    var i int = 42
    var s string = "hello"
    var f float64 = 3.14
    
    fmt.Printf("int类型: %T, 值: %v\n", i, i)
    fmt.Printf("string类型: %T, 值: %v\n", s, s)
    fmt.Printf("float64类型: %T, 值: %v\n", f, f)
    
    // 类型别名 vs 新类型
    type MyInt1 = int    // 类型别名
    type MyInt2 int      // 新类型
    
    var a MyInt1 = 10
    var b MyInt2 = 20
    
    fmt.Printf("类型别名MyInt1: %T\n", a)    // int
    fmt.Printf("新类型MyInt2: %T\n", b)      // main.MyInt2
    
    // 类型别名可以直接赋值
    i = a  // OK
    // i = b  // 编译错误：cannot use b (type MyInt2) as type int
    i = int(b)  // 需要显式转换
    fmt.Printf("转换后的值: %v\n", i)
}

// 接口类型与动态类型
type Animal interface {
    Speak() string
    Move() string
}

type Dog struct {
    Name string
}

func (d Dog) Speak() string {
    return d.Name + " says woof!"
}

func (d Dog) Move() string {
    return d.Name + " runs"
}

type Cat struct {
    Name string
}

func (c Cat) Speak() string {
    return c.Name + " says meow!"
}

func (c Cat) Move() string {
    return c.Name + " walks"
}

type Bird struct {
    Name string
}

func (b Bird) Speak() string {
    return b.Name + " says tweet!"
}

func (b Bird) Move() string {
    return b.Name + " flies"
}

// 类型断言基础
func basicTypeAssertion() {
    fmt.Println("\n=== 基本类型断言 ===")
    
    var animal Animal
    
    // 赋值不同类型
    animal = Dog{Name: "Buddy"}
    fmt.Printf("当前动物: %v, 类型: %T\n", animal, animal)
    
    // 类型断言 - 成功情况
    if dog, ok := animal.(Dog); ok {
        fmt.Printf("断言成功: %s, %s\n", dog.Speak(), dog.Move())
    } else {
        fmt.Println("不是Dog类型")
    }
    
    // 类型断言 - 失败情况
    if cat, ok := animal.(Cat); ok {
        fmt.Printf("断言成功: %s\n", cat.Speak())
    } else {
        fmt.Println("不是Cat类型")
    }
    
    // 不安全的类型断言（会panic）
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("捕获panic: %v\n", r)
        }
    }()
    
    animal = Dog{Name: "Max"}
    // cat := animal.(Cat)  // 这会panic
    // fmt.Println(cat.Speak())
}

// 类型选择（Type Switch）
func typeSwitch() {
    fmt.Println("\n=== 类型选择 ===")
    
    animals := []Animal{
        Dog{Name: "Buddy"},
        Cat{Name: "Whiskers"},
        Bird{Name: "Tweety"},
    }
    
    for i, animal := range animals {
        fmt.Printf("动物 %d: ", i+1)
        
        switch v := animal.(type) {
        case Dog:
            fmt.Printf("这是一只狗: %s, %s\n", v.Speak(), v.Move())
        case Cat:
            fmt.Printf("这是一只猫: %s, %s\n", v.Speak(), v.Move())
        case Bird:
            fmt.Printf("这是一只鸟: %s, %s\n", v.Speak(), v.Move())
        default:
            fmt.Printf("未知动物类型: %T\n", v)
        }
    }
}

// 空接口与类型断言
func emptyInterfaceAssertion() {
    fmt.Println("\n=== 空接口类型断言 ===")
    
    var values []interface{} = []interface{}{
        42,
        "hello",
        3.14,
        []int{1, 2, 3},
        map[string]int{"a": 1},
        Dog{Name: "Rex"},
    }
    
    for i, value := range values {
        fmt.Printf("值 %d: %v, 类型: %T\n", i+1, value, value)
        
        switch v := value.(type) {
        case int:
            fmt.Printf("  整数，平方: %d\n", v*v)
        case string:
            fmt.Printf("  字符串，长度: %d\n", len(v))
        case float64:
            fmt.Printf("  浮点数，两倍: %.2f\n", v*2)
        case []int:
            fmt.Printf("  整数切片，元素个数: %d\n", len(v))
        case map[string]int:
            fmt.Printf("  字符串到整数的映射，键值对个数: %d\n", len(v))
        case Dog:
            fmt.Printf("  狗: %s\n", v.Speak())
        default:
            fmt.Printf("  未处理的类型\n")
        }
    }
}

// 接口嵌套与类型断言
type Walker interface {
    Walk() string
}

type Swimmer interface {
    Swim() string
}

type Flyer interface {
    Fly() string
}

// 组合接口
type Amphibian interface {
    Walker
    Swimmer
}

type Penguin struct {
    Name string
}

func (p Penguin) Walk() string {
    return p.Name + " waddles"
}

func (p Penguin) Swim() string {
    return p.Name + " swims"
}

type Duck struct {
    Name string
}

func (d Duck) Walk() string {
    return d.Name + " walks"
}

func (d Duck) Swim() string {
    return d.Name + " swims"
}

func (d Duck) Fly() string {
    return d.Name + " flies"
}

func interfaceComposition() {
    fmt.Println("\n=== 接口组合与类型断言 ===")
    
    var creatures []interface{} = []interface{}{
        Penguin{Name: "Pingu"},
        Duck{Name: "Donald"},
    }
    
    for _, creature := range creatures {
        fmt.Printf("生物: %T\n", creature)
        
        // 检查是否实现了Walker接口
        if walker, ok := creature.(Walker); ok {
            fmt.Printf("  行走: %s\n", walker.Walk())
        }
        
        // 检查是否实现了Swimmer接口
        if swimmer, ok := creature.(Swimmer); ok {
            fmt.Printf("  游泳: %s\n", swimmer.Swim())
        }
        
        // 检查是否实现了Flyer接口
        if flyer, ok := creature.(Flyer); ok {
            fmt.Printf("  飞行: %s\n", flyer.Fly())
        }
        
        // 检查是否实现了组合接口
        if amphibian, ok := creature.(Amphibian); ok {
            fmt.Printf("  两栖动物: %s, %s\n", amphibian.Walk(), amphibian.Swim())
        }
    }
}

// 类型断言的性能考虑
func performanceConsiderations() {
    fmt.Println("\n=== 性能考虑 ===")
    
    var value interface{} = "hello world"
    
    // 方法1: 重复类型断言
    fmt.Println("--- 重复类型断言 ---")
    if _, ok := value.(string); ok {
        if s, ok := value.(string); ok {
            fmt.Printf("字符串长度: %d\n", len(s))
        }
    }
    
    // 方法2: 一次断言，重复使用
    fmt.Println("--- 一次断言，重复使用 ---")
    if s, ok := value.(string); ok {
        fmt.Printf("字符串长度: %d\n", len(s))
        fmt.Printf("字符串内容: %s\n", s)
    }
    
    // 方法3: 使用类型选择
    fmt.Println("--- 类型选择 ---")
    switch s := value.(type) {
    case string:
        fmt.Printf("字符串长度: %d\n", len(s))
        fmt.Printf("字符串内容: %s\n", s)
    default:
        fmt.Println("不是字符串")
    }
}

// 反射与类型断言
func reflectionAndAssertion() {
    fmt.Println("\n=== 反射与类型断言 ===")
    
    var value interface{} = Dog{Name: "Rover"}
    
    // 使用反射获取类型信息
    t := reflect.TypeOf(value)
    v := reflect.ValueOf(value)
    
    fmt.Printf("反射类型: %v\n", t)
    fmt.Printf("反射值: %v\n", v)
    fmt.Printf("类型名称: %s\n", t.Name())
    fmt.Printf("包路径: %s\n", t.PkgPath())
    
    // 反射调用方法
    if method := v.MethodByName("Speak"); method.IsValid() {
        result := method.Call(nil)
        fmt.Printf("方法调用结果: %v\n", result[0].String())
    }
    
    // 类型断言 vs 反射
    fmt.Println("\n--- 类型断言 vs 反射 ---")
    
    // 类型断言（更快）
    if dog, ok := value.(Dog); ok {
        fmt.Printf("类型断言: %s\n", dog.Speak())
    }
    
    // 反射（更灵活但较慢）
    if t.Name() == "Dog" {
        if speakMethod := v.MethodByName("Speak"); speakMethod.IsValid() {
            result := speakMethod.Call(nil)
            fmt.Printf("反射调用: %v\n", result[0].String())
        }
    }
}

// 最佳实践
func bestPractices() {
    fmt.Println("\n=== 最佳实践 ===")
    
    fmt.Println("1. 类型断言安全性:")
    fmt.Println("   - 始终使用comma ok idiom: v, ok := i.(T)")
    fmt.Println("   - 避免直接断言可能导致panic")
    
    fmt.Println("\n2. 性能优化:")
    fmt.Println("   - 类型选择比多次类型断言更高效")
    fmt.Println("   - 缓存断言结果避免重复断言")
    fmt.Println("   - 类型断言比反射更快")
    
    fmt.Println("\n3. 设计原则:")
    fmt.Println("   - 接受接口，返回具体类型")
    fmt.Println("   - 接口应该小而专注")
    fmt.Println("   - 在需要时才进行类型断言")
    
    fmt.Println("\n4. 错误处理:")
    fmt.Println("   - 处理类型断言失败的情况")
    fmt.Println("   - 使用defer+recover处理可能的panic")
    fmt.Println("   - 提供有意义的错误信息")
}

func main() {
    typeSystemBasics()
    basicTypeAssertion()
    typeSwitch()
    emptyInterfaceAssertion()
    interfaceComposition()
    performanceConsiderations()
    reflectionAndAssertion()
    bestPractices()
}
```

## 核心要点总结

**1. defer执行顺序**

- 遵循LIFO（后进先出）原则
- 参数在defer声明时确定值
- 即使发生panic也会执行

**2. 闭包应用**

- 可以捕获外部变量
- 注意循环变量的陷阱
- 适用于工厂模式和回调函数

**3. make vs new**

- `new`：分配内存，返回指针，值为零值
- `make`：初始化slice/map/chan，返回类型本身
- `make`只能用于slice、map、channel

**4. 参数传递**

- Go只有值传递
- 不同类型表现不同：基本类型完全复制，引用类型共享底层数据
- 指针传递的是指针值的副本

**5. nil的意义**

- 是多种类型的零值
- nil slice可安全使用，nil map写入会panic
- 接口的nil判断需要特别注意

**6. string与[]byte转换**

- 转换会分配新内存
- 考虑UTF-8编码
- 性能敏感场景可考虑优化

**7. 类型系统与断言**

- 静态类型系统
- 类型断言用于接口类型检查
- 使用comma ok idiom确保安全



# 并发编程 

## Goroutine 的使用与管理

### 基本用法

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 启动goroutine
    go func() {
        fmt.Println("匿名goroutine执行")
    }()
    
    // 启动命名函数goroutine
    go worker("worker-1")
    go worker("worker-2")
    
    // 主goroutine等待
    time.Sleep(time.Second)
}

func worker(name string) {
    for i := 0; i < 3; i++ {
        fmt.Printf("%s: %d\n", name, i)
        time.Sleep(100 * time.Millisecond)
    }
}
```

### Goroutine 池管理

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type WorkerPool struct {
    workerCount int
    jobs        chan Job
    wg          sync.WaitGroup
}

type Job struct {
    ID   int
    Data string
}

func NewWorkerPool(workerCount int) *WorkerPool {
    return &WorkerPool{
        workerCount: workerCount,
        jobs:        make(chan Job, 100), // 带缓冲的job队列
    }
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workerCount; i++ {
        wp.wg.Add(1)
        go wp.worker(i)
    }
}

func (wp *WorkerPool) worker(id int) {
    defer wp.wg.Done()
    for job := range wp.jobs {
        fmt.Printf("Worker %d processing job %d: %s\n", id, job.ID, job.Data)
        time.Sleep(100 * time.Millisecond) // 模拟工作
    }
}

func (wp *WorkerPool) Submit(job Job) {
    wp.jobs <- job
}

func (wp *WorkerPool) Stop() {
    close(wp.jobs)
    wp.wg.Wait()
}
```



## Channel 的基本用法与关闭规则

### 基本操作

```go
package main

import "fmt"

func main() {
    // 无缓冲channel
    ch1 := make(chan int)
    
    // 有缓冲channel
    ch2 := make(chan string, 3)
    
    // 只读channel
    var readOnly <-chan int = ch1
    
    // 只写channel
    var writeOnly chan<- int = ch1
    
    // 基本操作示例
    go func() {
        ch1 <- 42    // 发送
        ch2 <- "hello"
        close(ch2)   // 关闭channel
    }()
    
    // 接收
    value := <-ch1
    fmt.Println(value)
    
    // 检查channel是否关闭
    if value, ok := <-ch2; ok {
        fmt.Println("Received:", value)
    } else {
        fmt.Println("Channel closed")
    }
}
```

### Channel 关闭规则和最佳实践

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 生产者-消费者模式
func producerConsumer() {
    ch := make(chan int, 5)
    
    // 生产者
    go func() {
        defer close(ch) // 生产者负责关闭channel
        for i := 0; i < 10; i++ {
            ch <- i
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    // 消费者
    for value := range ch { // range会自动检测channel关闭
        fmt.Println("Consumed:", value)
    }
}

// 多生产者模式 - 使用sync.Once确保只关闭一次
func multiProducers() {
    ch := make(chan int, 10)
    var once sync.Once
    var wg sync.WaitGroup
    
    closeChannel := func() {
        once.Do(func() {
            close(ch)
        })
    }
    
    // 多个生产者
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            defer closeChannel() // 每个生产者都尝试关闭
            
            for j := 0; j < 3; j++ {
                select {
                case ch <- id*10 + j:
                case <-time.After(time.Second):
                    return // 超时退出
                }
            }
        }(i)
    }
    
    // 等待所有生产者完成
    go func() {
        wg.Wait()
        closeChannel()
    }()
    
    // 消费者
    for value := range ch {
        fmt.Println("Received:", value)
    }
}
```





## WaitGroup 的常见使用模式

### 基本用法

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func basicWaitGroup() {
    var wg sync.WaitGroup
    
    for i := 0; i < 5; i++ {
        wg.Add(1) // 增加等待计数
        go func(id int) {
            defer wg.Done() // 完成时减少计数
            fmt.Printf("Worker %d started\n", id)
            time.Sleep(time.Second)
            fmt.Printf("Worker %d finished\n", id)
        }(i)
    }
    
    wg.Wait() // 等待所有goroutine完成
    fmt.Println("All workers finished")
}
```

### 错误处理模式

```go
package main

import (
    "errors"
    "fmt"
    "sync"
)

func waitGroupWithError() {
    var wg sync.WaitGroup
    errCh := make(chan error, 5) // 错误收集channel
    
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // 模拟可能出错的工作
            if id == 2 {
                errCh <- errors.New("worker 2 failed")
                return
            }
            
            fmt.Printf("Worker %d completed successfully\n", id)
        }(i)
    }
    
    // 等待所有goroutine完成
    go func() {
        wg.Wait()
        close(errCh)
    }()
    
    // 收集错误
    var errors []error
    for err := range errCh {
        errors = append(errors, err)
    }
    
    if len(errors) > 0 {
        fmt.Printf("Encountered %d errors\n", len(errors))
        for _, err := range errors {
            fmt.Println("Error:", err)
        }
    }
}
```

### 限制并发数量

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func limitedConcurrency() {
    const maxConcurrency = 3
    sem := make(chan struct{}, maxConcurrency) // 信号量
    var wg sync.WaitGroup
    
    tasks := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    for _, task := range tasks {
        wg.Add(1)
        go func(taskID int) {
            defer wg.Done()
            
            sem <- struct{}{} // 获取信号量
            defer func() { <-sem }() // 释放信号量
            
            fmt.Printf("Processing task %d\n", taskID)
            time.Sleep(time.Second) // 模拟工作
            fmt.Printf("Task %d completed\n", taskID)
        }(task)
    }
    
    wg.Wait()
    fmt.Println("All tasks completed")
}
```



## Context 包的使用与超时控制

### 基本用法

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func basicContext() {
    // 创建带超时的context
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    // 传递context到函数
    result := doWork(ctx)
    fmt.Println("Result:", result)
}

func doWork(ctx context.Context) string {
    select {
    case <-time.After(1 * time.Second):
        return "work completed"
    case <-ctx.Done():
        return "work cancelled: " + ctx.Err().Error()
    }
}
```

### Context 传递和取消

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

func contextCancellation() {
    ctx, cancel := context.WithCancel(context.Background())
    var wg sync.WaitGroup
    
    // 启动多个worker
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go worker(ctx, i, &wg)
    }
    
    // 2秒后取消所有worker
    time.Sleep(2 * time.Second)
    cancel()
    
    wg.Wait()
    fmt.Println("All workers stopped")
}

func worker(ctx context.Context, id int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Worker %d stopped: %v\n", id, ctx.Err())
            return
        default:
            fmt.Printf("Worker %d working...\n", id)
            time.Sleep(500 * time.Millisecond)
        }
    }
}
```

### Context 值传递

```go
package main

import (
    "context"
    "fmt"
)

type contextKey string

const (
    userIDKey contextKey = "userID"
    traceIDKey contextKey = "traceID"
)

func contextValues() {
    ctx := context.Background()
    
    // 添加值到context
    ctx = context.WithValue(ctx, userIDKey, "user123")
    ctx = context.WithValue(ctx, traceIDKey, "trace456")
    
    processRequest(ctx)
}

func processRequest(ctx context.Context) {
    userID := ctx.Value(userIDKey)
    traceID := ctx.Value(traceIDKey)
    
    fmt.Printf("Processing request for user: %v, trace: %v\n", userID, traceID)
    
    // 传递给下一个函数
    handleRequest(ctx)
}

func handleRequest(ctx context.Context) {
    if userID, ok := ctx.Value(userIDKey).(string); ok {
        fmt.Printf("Handling request for user: %s\n", userID)
    }
}
```



## 并发安全的数据访问方法

### 使用 Mutex

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type SafeCounter struct {
    mu    sync.RWMutex
    count map[string]int
}

func NewSafeCounter() *SafeCounter {
    return &SafeCounter{
        count: make(map[string]int),
    }
}

func (c *SafeCounter) Inc(key string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.count[key]++
}

func (c *SafeCounter) Value(key string) int {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.count[key]
}

func (c *SafeCounter) GetAll() map[string]int {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    result := make(map[string]int)
    for k, v := range c.count {
        result[k] = v
    }
    return result
}
```

### 使用 sync.Map

```go
package main

import (
    "fmt"
    "sync"
)

func syncMapExample() {
    var sm sync.Map
    
    // 存储
    sm.Store("key1", "value1")
    sm.Store("key2", "value2")
    
    // 读取
    if value, ok := sm.Load("key1"); ok {
        fmt.Println("key1:", value)
    }
    
    // 读取或存储
    actual, loaded := sm.LoadOrStore("key3", "value3")
    fmt.Printf("key3: %v, was loaded: %v\n", actual, loaded)
    
    // 删除
    sm.Delete("key2")
    
    // 遍历
    sm.Range(func(key, value interface{}) bool {
        fmt.Printf("%v: %v\n", key, value)
        return true // 继续遍历
    })
}
```

### 使用 atomic 包

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

type AtomicCounter struct {
    count int64
}

func (c *AtomicCounter) Inc() {
    atomic.AddInt64(&c.count, 1)
}

func (c *AtomicCounter) Dec() {
    atomic.AddInt64(&c.count, -1)
}

func (c *AtomicCounter) Value() int64 {
    return atomic.LoadInt64(&c.count)
}

func atomicExample() {
    counter := &AtomicCounter{}
    var wg sync.WaitGroup
    
    // 并发增加计数
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Inc()
        }()
    }
    
    wg.Wait()
    fmt.Printf("Final count: %d\n", counter.Value())
}
```



##  Select 语句的使用与超时处理

### 基本 Select 用法

```go
package main

import (
    "fmt"
    "time"
)

func basicSelect() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "from ch1"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "from ch2"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println("Received", msg1)
        case msg2 := <-ch2:
            fmt.Println("Received", msg2)
        case <-time.After(3 * time.Second):
            fmt.Println("Timeout")
            return
        }
    }
}
```

### 非阻塞操作

```go
package main

import "fmt"

func nonBlocking() {
    ch := make(chan string, 1)
    ch <- "hello"
    
    select {
    case msg := <-ch:
        fmt.Println("Received:", msg)
    default:
        fmt.Println("No message received")
    }
    
    select {
    case ch <- "world":
        fmt.Println("Sent message")
    default:
        fmt.Println("Cannot send message")
    }
}
```

### 超时模式

```go
package main

import (
    "fmt"
    "time"
)

func requestWithTimeout(url string, timeout time.Duration) (string, error) {
    result := make(chan string, 1)
    errors := make(chan error, 1)
    
    go func() {
        // 模拟网络请求
        time.Sleep(2 * time.Second)
        result <- "response from " + url
    }()
    
    select {
    case res := <-result:
        return res, nil
    case err := <-errors:
        return "", err
    case <-time.After(timeout):
        return "", fmt.Errorf("request timeout after %v", timeout)
    }
}

func timeoutExample() {
    result, err := requestWithTimeout("http://example.com", 1*time.Second)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("Result:", result)
    }
}
```



## 常见并发模式的实现方式

### Pipeline 模式

```go
package main

import "fmt"

func pipeline() {
    // 阶段1: 生成数字
    numbers := make(chan int)
    go func() {
        defer close(numbers)
        for i := 1; i <= 10; i++ {
            numbers <- i
        }
    }()
    
    // 阶段2: 平方
    squares := make(chan int)
    go func() {
        defer close(squares)
        for n := range numbers {
            squares <- n * n
        }
    }()
    
    // 阶段3: 输出
    for s := range squares {
        fmt.Println(s)
    }
}
```

### Fan-in 模式

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func fanIn(inputs ...<-chan string) <-chan string {
    output := make(chan string)
    var wg sync.WaitGroup
    
    // 为每个输入channel启动一个goroutine
    for _, input := range inputs {
        wg.Add(1)
        go func(ch <-chan string) {
            defer wg.Done()
            for msg := range ch {
                output <- msg
            }
        }(input)
    }
    
    // 等待所有输入完成后关闭输出
    go func() {
        wg.Wait()
        close(output)
    }()
    
    return output
}

func fanInExample() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    ch3 := make(chan string)
    
    // 启动生产者
    go func() {
        defer close(ch1)
        for i := 0; i < 3; i++ {
            ch1 <- fmt.Sprintf("ch1-%d", i)
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    go func() {
        defer close(ch2)
        for i := 0; i < 3; i++ {
            ch2 <- fmt.Sprintf("ch2-%d", i)
            time.Sleep(150 * time.Millisecond)
        }
    }()
    
    go func() {
        defer close(ch3)
        for i := 0; i < 3; i++ {
            ch3 <- fmt.Sprintf("ch3-%d", i)
            time.Sleep(200 * time.Millisecond)
        }
    }()
    
    // 合并输出
    merged := fanIn(ch1, ch2, ch3)
    for msg := range merged {
        fmt.Println("Received:", msg)
    }
}
```

### Fan-out 模式

```go
package main

import (
    "fmt"
    "sync"
)

func fanOut(input <-chan int, workerCount int) []<-chan int {
    outputs := make([]<-chan int, workerCount)
    
    for i := 0; i < workerCount; i++ {
        output := make(chan int)
        outputs[i] = output
        
        go func(out chan<- int) {
            defer close(out)
            for data := range input {
                // 处理数据
                result := data * data
                out <- result
            }
        }(output)
    }
    
    return outputs
}

func fanOutExample() {
    input := make(chan int)
    
    // 生产者
    go func() {
        defer close(input)
        for i := 1; i <= 10; i++ {
            input <- i
        }
    }()
    
    // Fan-out到3个worker
    outputs := fanOut(input, 3)
    
    // 收集所有结果
    var wg sync.WaitGroup
    for i, output := range outputs {
        wg.Add(1)
        go func(workerID int, ch <-chan int) {
            defer wg.Done()
            for result := range ch {
                fmt.Printf("Worker %d produced: %d\n", workerID, result)
            }
        }(i, output)
    }
    
    wg.Wait()
}
```

### 发布-订阅模式

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type PubSub struct {
    mu          sync.RWMutex
    subscribers map[string][]chan string
}

func NewPubSub() *PubSub {
    return &PubSub{
        subscribers: make(map[string][]chan string),
    }
}

func (ps *PubSub) Subscribe(topic string) <-chan string {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    ch := make(chan string, 1)
    ps.subscribers[topic] = append(ps.subscribers[topic], ch)
    return ch
}

func (ps *PubSub) Publish(topic, message string) {
    ps.mu.RLock()
    defer ps.mu.RUnlock()
    
    for _, ch := range ps.subscribers[topic] {
        select {
        case ch <- message:
        default: // 非阻塞发送
        }
    }
}

func pubSubExample() {
    ps := NewPubSub()
    
    // 订阅者1
    sub1 := ps.Subscribe("news")
    go func() {
        for msg := range sub1 {
            fmt.Printf("Subscriber 1 received: %s\n", msg)
        }
    }()
    
    // 订阅者2
    sub2 := ps.Subscribe("news")
    go func() {
        for msg := range sub2 {
            fmt.Printf("Subscriber 2 received: %s\n", msg)
        }
    }()
    
    // 发布消息
    time.Sleep(100 * time.Millisecond)
    ps.Publish("news", "Breaking news!")
    ps.Publish("news", "Weather update")
    
    time.Sleep(time.Second)
}
```

### 生产者-消费者模式

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Buffer struct {
    items   []string
    maxSize int
    mu      sync.Mutex
    notFull *sync.Cond
    notEmpty *sync.Cond
}

func NewBuffer(maxSize int) *Buffer {
    b := &Buffer{
        items:   make([]string, 0, maxSize),
        maxSize: maxSize,
    }
    b.notFull = sync.NewCond(&b.mu)
    b.notEmpty = sync.NewCond(&b.mu)
    return b
}

func (b *Buffer) Put(item string) {
    b.mu.Lock()
    defer b.mu.Unlock()
    
    for len(b.items) == b.maxSize {
        b.notFull.Wait() // 等待空间
    }
    
    b.items = append(b.items, item)
    b.notEmpty.Signal() // 通知消费者
}

func (b *Buffer) Get() string {
    b.mu.Lock()
    defer b.mu.Unlock()
    
    for len(b.items) == 0 {
        b.notEmpty.Wait() // 等待数据
    }
    
    item := b.items[0]
    b.items = b.items[1:]
    b.notFull.Signal() // 通知生产者
    return item
}

func producerConsumerExample() {
    buffer := NewBuffer(3)
    var wg sync.WaitGroup
    
    // 生产者
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 10; i++ {
            item := fmt.Sprintf("item-%d", i)
            buffer.Put(item)
            fmt.Printf("Produced: %s\n", item)
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    // 消费者
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 10; i++ {
            item := buffer.Get()
            fmt.Printf("Consumed: %s\n", item)
            time.Sleep(200 * time.Millisecond)
        }
    }()
    
    wg.Wait()
}
```



## 最佳实践总结

1. Goroutine 管理：
   - 避免goroutine泄漏，确保所有goroutine都能正常退出
   - 使用goroutine池来控制并发数量
   - 合理使用WaitGroup等待goroutine完成
2. Channel 使用：
   - 遵循"发送方关闭channel"的原则
   - 使用带缓冲的channel来解耦生产者和消费者
   - 使用select实现非阻塞操作和超时控制
3. 并发安全：
   - 优先使用channel进行通信
   - 必要时使用sync包提供的同步原语
   - 对于简单的计数器操作，优先使用atomic包
4. Context 使用：
   - 在函数间传递context来控制取消和超时
   - 不要在结构体中存储context
   - 使用context.Value传递请求级别的数据
5. 错误处理：
   - 使用专门的错误channel收集goroutine中的错误
   - 在并发环境中要特别注意错误处理的线程安全性



# 实⽤编程技巧

## Go 中的错误处理最佳实践

### 基本错误处理原则

Go语言采用显式错误处理，避免使用异常机制。每个可能出错的函数都应该返回error类型。

```go
// 基本错误处理模式
func ReadFile(filename string) ([]byte, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("读取文件失败 %s: %w", filename, err)
    }
    return data, nil
}

// 调用方式
data, err := ReadFile("config.json")
if err != nil {
    log.Fatal(err)
}
```



### 错误包装与展开

使用`fmt.Errorf`的`%w`动词包装错误，保留错误链。

```go
package main

import (
    "errors"
    "fmt"
)

var ErrNotFound = errors.New("资源未找到")

func GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, fmt.Errorf("无效的用户ID %d: %w", id, ErrNotFound)
    }
    // 模拟数据库查询
    return nil, fmt.Errorf("数据库查询失败: %w", ErrNotFound)
}

func main() {
    _, err := GetUser(-1)
    if err != nil {
        // 检查是否为特定错误
        if errors.Is(err, ErrNotFound) {
            fmt.Println("处理未找到错误")
        }
        
        // 展开错误链
        fmt.Printf("错误详情: %v\n", err)
    }
}
```



### 自定义错误类型

```go
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("验证失败 [%s]: %s", e.Field, e.Message)
}

func ValidateUser(user *User) error {
    if user.Email == "" {
        return &ValidationError{
            Field:   "email",
            Message: "邮箱不能为空",
        }
    }
    return nil
}
```



## 结构体嵌套与组合的实际应用

### 结构体嵌套

```go
type Address struct {
    Street   string
    City     string
    Country  string
    PostCode string
}

type Person struct {
    Name    string
    Age     int
    Address Address // 嵌套结构体
}

type Employee struct {
    Person      // 匿名嵌套，继承Person的所有字段
    ID          int
    Department  string
    Salary      float64
}

func main() {
    emp := Employee{
        Person: Person{
            Name: "张三",
            Age:  30,
            Address: Address{
                Street:   "中山路123号",
                City:     "上海",
                Country:  "中国",
                PostCode: "200000",
            },
        },
        ID:         1001,
        Department: "技术部",
        Salary:     15000.0,
    }
    
    // 直接访问嵌套字段
    fmt.Println(emp.Name)        // 来自Person
    fmt.Println(emp.Address.City) // 来自Address
}
```



### 组合模式实现

```go
// 定义接口
type Writer interface {
    Write(data []byte) error
}

type Reader interface {
    Read() ([]byte, error)
}

// 基础实现
type FileHandler struct {
    filename string
}

func (f *FileHandler) Write(data []byte) error {
    return os.WriteFile(f.filename, data, 0644)
}

func (f *FileHandler) Read() ([]byte, error) {
    return os.ReadFile(f.filename)
}

// 通过组合添加功能
type LoggedFileHandler struct {
    FileHandler // 组合
    logger      *log.Logger
}

func (l *LoggedFileHandler) Write(data []byte) error {
    l.logger.Printf("写入文件: %s, 大小: %d bytes", l.filename, len(data))
    return l.FileHandler.Write(data)
}

func (l *LoggedFileHandler) Read() ([]byte, error) {
    l.logger.Printf("读取文件: %s", l.filename)
    return l.FileHandler.Read()
}
```



## 接口的设计原则与实现技巧

### 接口设计原则

**保持接口小而专一** - 遵循单一职责原则

```go
// 好的设计 - 小接口
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type Closer interface {
    Close() error
}

// 组合接口
type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```



### 接口实现技巧

```go
// 定义行为接口
type PaymentProcessor interface {
    ProcessPayment(amount float64) error
}

type NotificationSender interface {
    SendNotification(message string) error
}

// 具体实现
type AlipayProcessor struct {
    AppID string
}

func (a *AlipayProcessor) ProcessPayment(amount float64) error {
    fmt.Printf("支付宝支付: %.2f元\n", amount)
    return nil
}

type WeChatProcessor struct {
    MerchantID string
}

func (w *WeChatProcessor) ProcessPayment(amount float64) error {
    fmt.Printf("微信支付: %.2f元\n", amount)
    return nil
}

// 使用接口实现多态
type PaymentService struct {
    processor PaymentProcessor
}

func (p *PaymentService) Pay(amount float64) error {
    return p.processor.ProcessPayment(amount)
}

func main() {
    // 可以轻松切换支付方式
    alipay := &PaymentService{processor: &AlipayProcessor{AppID: "123"}}
    wechat := &PaymentService{processor: &WeChatProcessor{MerchantID: "456"}}
    
    alipay.Pay(100.0)
    wechat.Pay(200.0)
}
```



###  空接口的使用

```go
// 通用容器
type Container struct {
    items []interface{}
}

func (c *Container) Add(item interface{}) {
    c.items = append(c.items, item)
}

// 类型断言
func (c *Container) GetString(index int) (string, bool) {
    if index >= len(c.items) {
        return "", false
    }
    
    str, ok := c.items[index].(string)
    return str, ok
}
```



## Go 代码的性能优化常见方法



### 切片预分配容量

```go
// 低效 - 频繁扩容
func inefficientSlice() []int {
    var result []int
    for i := 0; i < 1000; i++ {
        result = append(result, i)
    }
    return result
}

// 高效 - 预分配容量
func efficientSlice() []int {
    result := make([]int, 0, 1000) // 预分配容量
    for i := 0; i < 1000; i++ {
        result = append(result, i)
    }
    return result
}
```



###  字符串构建优化

```go
import "strings"

// 低效 - 字符串连接
func inefficientStringBuilding(words []string) string {
    var result string
    for _, word := range words {
        result += word + " "
    }
    return result
}

// 高效 - 使用strings.Builder
func efficientStringBuilding(words []string) string {
    var builder strings.Builder
    builder.Grow(len(words) * 10) // 预估大小
    
    for _, word := range words {
        builder.WriteString(word)
        builder.WriteString(" ")
    }
    return builder.String()
}
```





###  避免不必要的内存分配

```go
// 复用对象池
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 0, 1024)
    },
}

func processData(data []byte) []byte {
    // 从池中获取buffer
    buffer := bufferPool.Get().([]byte)
    defer bufferPool.Put(buffer[:0]) // 重置并归还
    
    // 处理数据
    buffer = append(buffer, data...)
    // 进行其他处理...
    
    result := make([]byte, len(buffer))
    copy(result, buffer)
    return result
}
```



##  Go 程序的内存管理与优化

### 理解垃圾回收

```go
import (
    "runtime"
    "runtime/debug"
)

func memoryStats() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    fmt.Printf("分配的内存: %d KB\n", m.Alloc/1024)
    fmt.Printf("总分配次数: %d\n", m.Mallocs)
    fmt.Printf("GC次数: %d\n", m.NumGC)
}

// 手动触发GC（一般不推荐）
func forceGC() {
    runtime.GC()
    debug.FreeOSMemory()
}
```



### 理解垃圾回收

```go
import (
    "runtime"
    "runtime/debug"
)

func memoryStats() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    fmt.Printf("分配的内存: %d KB\n", m.Alloc/1024)
    fmt.Printf("总分配次数: %d\n", m.Mallocs)
    fmt.Printf("GC次数: %d\n", m.NumGC)
}

// 手动触发GC（一般不推荐）
func forceGC() {
    runtime.GC()
    debug.FreeOSMemory()
}
```



## 反射的使用场景与注意事项

### 反射基本使用

```go
import "reflect"

func analyzeStruct(v interface{}) {
    rv := reflect.ValueOf(v)
    rt := reflect.TypeOf(v)
    
    // 处理指针
    if rv.Kind() == reflect.Ptr {
        rv = rv.Elem()
        rt = rt.Elem()
    }
    
    fmt.Printf("类型: %s\n", rt.Name())
    
    // 遍历字段
    for i := 0; i < rv.NumField(); i++ {
        field := rt.Field(i)
        value := rv.Field(i)
        
        fmt.Printf("字段: %s, 类型: %s, 值: %v\n", 
            field.Name, field.Type, value.Interface())
    }
}

type User struct {
    Name  string `json:"name" validate:"required"`
    Email string `json:"email" validate:"email"`
    Age   int    `json:"age" validate:"min=18"`
}

func main() {
    user := User{Name: "张三", Email: "zhang@example.com", Age: 25}
    analyzeStruct(user)
}
```



###  反射实现通用验证器

```go
func validateStruct(v interface{}) []error {
    var errors []error
    rv := reflect.ValueOf(v)
    rt := reflect.TypeOf(v)
    
    if rv.Kind() == reflect.Ptr {
        rv = rv.Elem()
        rt = rt.Elem()
    }
    
    for i := 0; i < rv.NumField(); i++ {
        field := rt.Field(i)
        value := rv.Field(i)
        
        // 检查required标签
        if tag := field.Tag.Get("validate"); tag == "required" {
            if value.Kind() == reflect.String && value.String() == "" {
                errors = append(errors, fmt.Errorf("字段 %s 不能为空", field.Name))
            }
        }
    }
    
    return errors
}
```



###  反射注意事项

```go
// 性能影响 - 避免在热路径中使用反射
func BenchmarkReflection(b *testing.B) {
    user := User{Name: "test", Email: "test@example.com", Age: 25}
    
    b.Run("Direct", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            _ = user.Name // 直接访问
        }
    })
    
    b.Run("Reflection", func(b *testing.B) {
        rv := reflect.ValueOf(user)
        for i := 0; i < b.N; i++ {
            _ = rv.FieldByName("Name").String() // 反射访问
        }
    })
}
```



##  Go 工程化最佳实践

### 项目结构

```
myproject/
├── cmd/                    # 应用程序入口
│   └── myapp/
│       └── main.go
├── internal/               # 私有应用代码
│   ├── handler/           # HTTP处理器
│   ├── service/           # 业务逻辑
│   ├── repository/        # 数据访问层
│   └── config/            # 配置管理
├── pkg/                    # 可被外部使用的库代码
│   └── utils/
├── api/                    # API定义
├── web/                    # Web资源
├── scripts/                # 脚本
├── deployments/            # 部署配置
├── test/                   # 测试文件
├── docs/                   # 文档
├── go.mod
├── go.sum
├── Makefile
└── README.md
```



###  依赖管理

```go
// go.mod 示例
module github.com/username/myproject

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/spf13/viper v1.16.0
    gorm.io/gorm v1.25.2
)

require (
    // 间接依赖...
)
```

### 配置管理

```go
package config

import (
    "github.com/spf13/viper"
)

type Config struct {
    Server   ServerConfig   `mapstructure:"server"`
    Database DatabaseConfig `mapstructure:"database"`
    Redis    RedisConfig    `mapstructure:"redis"`
}

type ServerConfig struct {
    Port         int    `mapstructure:"port"`
    Host         string `mapstructure:"host"`
    ReadTimeout  int    `mapstructure:"read_timeout"`
    WriteTimeout int    `mapstructure:"write_timeout"`
}

type DatabaseConfig struct {
    Host     string `mapstructure:"host"`
    Port     int    `mapstructure:"port"`
    Username string `mapstructure:"username"`
    Password string `mapstructure:"password"`
    Database string `mapstructure:"database"`
}

func Load() (*Config, error) {
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")
    viper.AddConfigPath(".")
    viper.AddConfigPath("./configs")
    
    // 环境变量支持
    viper.AutomaticEnv()
    viper.SetEnvPrefix("MYAPP")
    
    if err := viper.ReadInConfig(); err != nil {
        return nil, err
    }
    
    var cfg Config
    if err := viper.Unmarshal(&cfg); err != nil {
        return nil, err
    }
    
    return &cfg, nil
}
```



### 日志管理

```go
package logger

import (
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)

var Logger *zap.Logger

func Init(level string, isDevelopment bool) error {
    var config zap.Config
    
    if isDevelopment {
        config = zap.NewDevelopmentConfig()
    } else {
        config = zap.NewProductionConfig()
    }
    
    // 设置日志级别
    switch level {
    case "debug":
        config.Level = zap.NewAtomicLevelAt(zapcore.DebugLevel)
    case "info":
        config.Level = zap.NewAtomicLevelAt(zapcore.InfoLevel)
    case "warn":
        config.Level = zap.NewAtomicLevelAt(zapcore.WarnLevel)
    case "error":
        config.Level = zap.NewAtomicLevelAt(zapcore.ErrorLevel)
    }
    
    var err error
    Logger, err = config.Build()
    if err != nil {
        return err
    }
    
    return nil
}

func Debug(msg string, fields ...zap.Field) {
    Logger.Debug(msg, fields...)
}

func Info(msg string, fields ...zap.Field) {
    Logger.Info(msg, fields...)
}

func Error(msg string, fields ...zap.Field) {
    Logger.Error(msg, fields...)
}
```



### 测试策略

```go
// 单元测试
func TestUserService_CreateUser(t *testing.T) {
    tests := []struct {
        name    string
        input   CreateUserRequest
        want    *User
        wantErr bool
    }{
        {
            name: "valid user",
            input: CreateUserRequest{
                Name:  "张三",
                Email: "zhang@example.com",
            },
            want: &User{
                Name:  "张三",
                Email: "zhang@example.com",
            },
            wantErr: false,
        },
        {
            name: "invalid email",
            input: CreateUserRequest{
                Name:  "张三",
                Email: "invalid-email",
            },
            want:    nil,
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            service := NewUserService()
            got, err := service.CreateUser(tt.input)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("CreateUser() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("CreateUser() got = %v, want %v", got, tt.want)
            }
        })
    }
}
```



###  Makefile 自动化

```makefile
.PHONY: build test clean run lint

# 构建
build:
	go build -o bin/myapp ./cmd/myapp

# 测试
test:
	go test -v ./...

# 测试覆盖率
test-coverage:
	go test -v -coverprofile=coverage.out ./...
	go tool cover -html=coverage.out

# 代码检查
lint:
	golangci-lint run

# 运行
run:
	go run ./cmd/myapp

# 清理
clean:
	rm -rf bin/
	rm -f coverage.out

# 安装依赖
deps:
	go mod download
	go mod tidy

# Docker构建
docker-build:
	docker build -t myapp .

# 部署
deploy:
	kubectl apply -f deployments/
```
